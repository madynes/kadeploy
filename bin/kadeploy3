#!/usr/bin/ruby -w

# Kadeploy 3.1
# Copyright (c) by INRIA, Emmanuel Jeanvoine - 2008-2011
# CECILL License V2 - http://www.cecill.info
# For details on use and redistribution please refer to License.txt

$kadeploy_libs=ENV['KADEPLOY3_LIBS']||'/usr/local/kadeploy3/src/lib'
$kadeploy_config_directory='/etc/kadeploy3'

$:.unshift($kadeploy_libs)

require 'client'

API_DIR = 'deploy'

Signal.trap("INT") do
  puts "\nSIGINT trapped, let's clean everything ..."
  KadeployClient.kill()
  exit!(1)
end

class KadeployClient << Client
  def initialize()
    super()
  end

  def run(options)
    raise
  end

  def self.load_options()
    options = OpenStruct.new
    options.environment = EnvironmentManagement::Environment.new
    options.nodesetid = 0
    options.node_set = Nodes::NodeSet.new(options.nodesetid)
    options.node_array = Array.new
    options.load_env_kind = String.new
    options.load_env_desc = String.new
    options.load_env_file = String.new
    options.env_version = nil #By default we load the latest version
    options.user = nil
    options.true_user = USER
    options.block_device = String.new
    options.deploy_part = String.new
    options.boot_part = nil
    options.verbose_level = nil
    options.debug = false
    options.script = String.new
    options.key = String.new
    options.reformat_tmp = false
    options.pxe_profile_msg = String.new
    options.pxe_upload_files = Array.new
    options.pxe_profile_singularities = nil
    options.steps = Array.new
    options.ignore_nodes_deploying = false
    options.breakpoint_on_microstep = String.new
    options.breakpointed = false
    options.custom_operations_file = String.new
    options.custom_operations = nil
    options.disable_bootloader_install = false
    options.disable_disk_partitioning = false
    options.nodes_ok_file = String.new
    options.nodes_ko_file = String.new
    options.nodes_state = Hash.new
    options.write_workflow_id = String.new
    options.get_version = false
    options.get_users_info = false
    options.chosen_server = String.new
    options.servers = Config.load_client_config_file
    options.multi_server = false
    options.kadeploy_server = String.new
    options.kadeploy_server_port = String.new
    options.reboot_classical_timeout = nil
    options.reboot_kexec_timeout = nil
    options.vlan = nil
    options.ip_in_vlan = nil
  end

  def self.parse_options()
    options = load_options()
    opts = OptionParser::new do |opt|
      opt.summary_indent = "  "
      opt.summary_width = 32
      opt.banner = "Usage: kadeploy3 [options]"
      opt.separator "Contact: #{CONTACT_EMAIL}"
      opt.separator ""
      opt.separator "General options:"
      opt.on("-a", "--env-file ENVFILE", "File containing the environment description") { |f|
        if tmp = load_envfile(f)
          options.load_env_file = f
          options.load_env_desc = tmp
          options.load_env_kind = "file"
        else
          return false
        end
      }
      opt.on("-b", "--block-device BLOCKDEVICE", "Specify the block device to use") { |b|
        if /\A[\w\/]+\Z/ =~ b then
          options.block_device = b
          options.deploy_part = nil if options.deploy_part.empty?
        else
          error("Invalid block device")
          return false
        end
      }
      opt.on("-c", "--boot-partition NUMBER", "Specify the number of the partition to boot on (use 0 to boot on the MBR)") { |c|
        if /\A\d+\Z/ =~ c then
          options.boot_part = c.to_i
        else
          error("Invalid chainload partition number")
          return false
        end
      }
      opt.on("-d", "--debug-mode", "Activate the debug mode") {
        options.debug = true
      }
      opt.on("-e", "--env-name ENVNAME", "Name of the recorded environment to deploy") { |n|
        options.load_env_kind = "db"
        options.load_env_desc = n
      }
      opt.on("-f", "--file MACHINELIST", "Files containing list of nodes (- means stdin)")  { |f|
        load_machinefile(options.node_array, f)
      }
      opt.on("-i", "--server-info", "Get information about the server's configuration") {
        options.get_users_info = true
      }
      opt.on("-k", "--key [FILE]", "Public key to copy in the root's authorized_keys, if no argument is specified, use the authorized_keys") { |f|
        if (f != nil) then
          if (f =~ R_HTTP) then
            options.key = f
          else
            if not File.readable?(f) then
              error("The file #{f} cannot be read")
              return false
            else
              options.key = File.expand_path(f)
            end
          end
        else
          authorized_keys = File.expand_path("~/.ssh/authorized_keys")
          if File.readable?(authorized_keys) then
            options.key = authorized_keys
          else
            error("The authorized_keys file #{authorized_keys} cannot be read")
            return false
          end
        end
      }
      opt.on("-m", "--machine MACHINE", "Node to run on") { |hostname|
        load_machine(options.node_array, hostname)
      }
      opt.on("--multi-server", "Activate the multi-server mode") {
        options.multi_server = true
      }
      opt.on("-n", "--output-ko-nodes FILENAME", "File that will contain the nodes not correctly deployed")  { |f|
        options.nodes_ko_file = f
      }
      opt.on("-o", "--output-ok-nodes FILENAME", "File that will contain the nodes correctly deployed")  { |f|
        options.nodes_ok_file = f
      }
      opt.on("-p", "--partition-number NUMBER", "Specify the partition number to use") { |p|
        if /\A\d+\Z/ =~ p then
          options.deploy_part = p
        else
          error("Invalid partition number")
          return false
        end
      }
      opt.on("-r", "--reformat-tmp FSTYPE", "Reformat the /tmp partition with the given filesystem type (this filesystem need to be supported by the deployment environment)") { |t|
        options.reformat_tmp = true
        options.reformat_tmp_fstype = t
      }
      opt.on("-s", "--script FILE", "Execute a script at the end of the deployment") { |f|
        if not File.readable?(f) then
          error("The file #{f} cannot be read")
          return false
        else
          if not File.stat(f).executable? then
            error("The file #{f} must be executable to be run at the end of the deployment")
            return false
          else
            options.script = File.expand_path(f)
          end
        end
      }
      opt.on("-u", "--user USERNAME", "Specify the user") { |u|
        if /\A\w+\Z/ =~ u then
          options.user = u
        else
          error("Invalid user name")
          return false
        end
      }
      opt.on("-v", "--version", "Get the version") {
        options.get_version = true
      }
      opt.on("--vlan VLANID", "Set the VLAN") { |id|
        options.vlan = id
      }
      opt.on("-w", "--set-pxe-profile FILE", "Set the PXE profile (use with caution)") { |f|
        if not File.readable?(f) then
          error("The file #{f} cannot be read")
          return false
        else
          IO.readlines(f).each { |l|
            options.pxe_profile_msg.concat(l)
          }
        end
      }
      opt.on("--set-pxe-pattern FILE", "Specify a file containing the substituation of a pattern for each node in the PXE profile (the NODE_SINGULARITY pattern must be used in the PXE profile)") { |f|
        if not File.readable?(f) then
          error("The file #{f} cannot be read")
          return false
        else
          options.pxe_profile_singularities = Hash.new
          IO.readlines(f).each { |l|
            if !(/^#/ =~ l) and !(/^$/ =~ l) then #we ignore commented and empty lines
              content = l.split(",")
              options.pxe_profile_singularities[content[0]] = content[1].strip
            end
          }
        end
      }
      opt.on("-x", "--upload-pxe-files FILES", "Upload a list of files (file1,file2,file3) to the PXE kernels repository. Those files will then be available with the prefix FILES_PREFIX-- ") { |l|
        l.split(",").each { |file|
          if (file =~ R_HTTP) then
            options.pxe_upload_files.push(file) 
          else
            f = File.expand_path(file)
            if not File.readable?(f) then
              error("The file #{f} cannot be read")
              return false
            else
              options.pxe_upload_files.push(f) 
            end
          end
        }
      }
      opt.on("--env-version NUMBER", "Number of version of the environment to deploy") { |n|
        if /\A\d+\Z/ =~ n then
          options.env_version = n
        else
          error("Invalid version number")
          return false
        end
      }
      opt.on("--server STRING", "Specify the Kadeploy server to use") { |s|
        options.chosen_server = s
      } 
      opt.on("-V", "--verbose-level VALUE", "Verbose level between 0 to 5") { |d|
        if d =~ /\A\d+\Z/ then
          options.verbose_level = d.to_i
        else
          error("Invalid verbose level")
          return false
        end
      }
      opt.separator "Advanced options:"
      opt.on("--write-workflow-id FILE", "Write the workflow id in a file") { |file|
        options.write_workflow_id = file
      }
      opt.on("--ignore-nodes-deploying", "Allow to deploy even on the nodes tagged as \"currently deploying\" (use this only if you know what you do)") {
        options.ignore_nodes_deploying = true
      }        
      opt.on("--disable-bootloader-install", "Disable the automatic installation of a bootloader for a Linux based environnment") {
        options.disable_bootloader_install = true
      }
      opt.on("--disable-disk-partitioning", "Disable the disk partitioning") {
        options.disable_disk_partitioning = true
      }
      opt.on("--breakpoint MICROSTEP", "Set a breakpoint just before lauching the given micro-step, the syntax is macrostep:microstep (use this only if you know what you do)") { |m|
        tmp = m.split(':',2)
        if check_macrostep_instance(tmp[0])
          if check_microstep(tmp[1])
            options.breakpoint_on_microstep = m
          else
            error("The microstep #{tmp[1]} for the breakpoint entry is invalid")
            return false
          end
        else
          error("The macrostep #{tmp[0]} for the breakpoint entry is invalid")
          return false
        end
      }
      opt.on("--set-custom-operations FILE", "Add some custom operations defined in a file") { |file|
        return false unless Config.load_custom_ops_file(options,file)
      }
      opt.on("--reboot-classical-timeout V", "Overload the default timeout for classical reboots") { |t|
        if (t =~ /\A\d+\Z/) then
          options.reboot_classical_timeout = t
        else
          error("A number is required for the reboot classical timeout")
        end
      }
      opt.on("--reboot-kexec-timeout V", "Overload the default timeout for kexec reboots") { |t|
        if (t =~ /\A\d+\Z/) then
          options.reboot_kexec_timeout = t
        else
          error("A number is required for the reboot kexec timeout")
        end
      }
      opt.on("--force-steps STRING", "Undocumented, for administration purpose only") { |s|
        # Gathering a list of availables microsteps
        microsteps = Microstep.instance_methods.select{
          |name| name =~ /^ms_/
        }
        microsteps.collect!{ |name| name.to_s.sub(/^ms_/,'') }

        # Gathering a list of availables macrosteps
        macrosteps = ObjectSpace.each_object(Class).select { |klass|
          klass.ancestors.include?(Macrostep)
        }
        macrointerfaces = ObjectSpace.each_object(Class).select { |klass|
          klass.superclass == Macrostep
        }
        # Do not consider rought step names as valid
        macrointerfaces.each { |interface| macrosteps.delete(interface) }
        macrointerfaces.collect! { |klass| klass.name }
        macrosteps.collect!{ |klass| klass.name }

        s.split("&").each { |macrostep|
          macroname = macrostep.split("|")[0]
          unless macrointerfaces.include?(macroname)
            error("Invalid macrostep kind '#{macroname}'")
            return false
          end
          instances = macrostep.split("|")[1]
          insts = []

          instances.split(",").each { |instance|
            inst_name = instance.split(":")[0]
            unless macrosteps.include?(inst_name)
              error("Invalid macrostep instance '#{inst_name}'")
              return false
            end
            inst_retries = instance.split(":")[1]
            begin
              inst_retries = Integer(inst_retries)
            rescue ArgumentError
              error("The number of retries '#{inst_retries}' is not an integer")
              return false
            end
            inst_timeout = instance.split(":")[2]
            begin
              inst_timeout = Integer(inst_timeout)
            rescue ArgumentError
              error("The timeout '#{inst_timeout}' is not an integer")
              return false
            end

            insts << [inst_name, inst_retries, inst_timeout]
          }
          options.steps.push(MacroStep.new(macroname, insts))
        }
      }
    end
    @opts = opts
    begin
      opts.parse!(ARGV)
    rescue
      error("Option parsing error: #{$!}")
      return false
    end

    if (options.chosen_server != "") then
      if not options.servers.has_key?(options.chosen_server) then
        error("The #{options.chosen_server} server is not defined in the configuration: #{(options.servers.keys - ["default"]).join(", ")} values are allowed")
        return false
      end
    else
      options.chosen_server = options.servers["default"]
    end
    options.kadeploy_server = options.servers[options.chosen_server][0]
    options.kadeploy_server_port = options.servers[options.chosen_server][1]

    if not options.get_version and not options.get_users_info then
      if options.node_array.empty? then
        error("You must specify some nodes to deploy")
        return false
      end
      if (options.nodes_ok_file != "") && (options.nodes_ok_file == options.nodes_ko_file) then
        error("The files used for the output of the OK and the KO nodes must not be the same")
        return false
      end
    end
    return true
  end
end

KadeployClient.launch()
