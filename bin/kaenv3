#!/usr/bin/ruby -w

$kadeploy_libs=ENV['KADEPLOY3_LIBS']||'/usr/local/kadeploy3/src/lib'

$:.unshift($kadeploy_libs)

require 'optparse'
require 'client'

Signal.trap("INT") do
  $stdout.puts "\nSIGINT trapped"
  Kadeploy::KaenvClient.kill() rescue nil
  exit!(1)
end

module Kadeploy

class KaenvsClient < Client
  def print_headers()
    debug sprintf("%-21s %-7s %-11s %.35s\n",'Name','Version','User','Description')
    debug sprintf("%-21s %-7s %-11s %.35s\n",'####','#######','####','###########')
  end

  def print_short(env)
    debug sprintf("%-21s %-7s %-11s %.35s%.3s\n", env['name'], env['version'], env['user'], env['description'],(env['description'].size>35 ? '...' : ''))
  end

  def print_full(env)
    env.delete('user')
    debug env.to_yaml
    #YAML::quick_emit(env) do |out|
    #  out.map(env.taguri(), env.to_yaml_style()) do |map|
    #    env.keys.sort do |x,y|
    #      tmpx = YAML_SORT.index(x)
    #      tmpy = YAML_SORT.index(y)
    #      tmpx,tmpy = [x.to_s,y.to_s] if !tmpx and !tmpy
    #      (tmpx || max+1) <=> (tmpy || max+2)
    #    end.each{ |k| map.add(k, env[k]) }
    #    #content_hash.sort_by { |k,v| k }.each{ |t| map.add(t[0],t[1]) }
    #    #content_hash.keys.sort.each { |k| map.add(k, content_hash[k]) }
    #  end
    #end
  end

  def self.operation()
    'Environment management'
  end

  def self.load_options()
    global_load_options().merge(
      {
        :environment => {},
        :operation => nil,
        :env_desc => {},
        :env_name => '',
        :env_version => nil,
        :user => nil,
        :all_versions => false,
        :visibility_tag => nil,
        :files_to_move => {},
        :secure => false,
      }
    )
  end

  def self.parse_options()
    global_parse_options() do |opt,options|
      opt.separator "General options:"
      opt.on("-a", "--add ENVFILE", "Add an environment") { |f|
        options[:operation] = :add
        load_envfile(options[:env_desc],f)
      }
      opt.on("-d", "--delete ENVNAME", "Delete an environment") { |n|
        options[:env_name] = n
        options[:operation] = :delete
      }
      opt.on("-l", "--list", "List environments") {
        options[:operation] = :list
      }
      opt.on("-m", "--files-to-move FILES", "Files to move (src1::dst1,src2::dst2,...)") { |f|
        if /\A.+::.+(,.+::.+)*\Z/ =~f then
          f.split(",").each do |src_dst|
            tmp = src_dst.split("::",2)
            options[:files_to_move][tmp[0]] = tmp[1]
          end
        else
          error("Invalid synthax for files to move")
          return false
        end
      }
      opt.on("-p", "--print ENVNAME", "Print an environment") { |n|
        options[:env_name] = n
        options[:operation] = :print
      }
      opt.on("-s", "--all-versions", "Apply the operation on all the versions of the environment") {
        options[:all_versions] = true
      }
      opt.on("-t", "--visibility-tag TAG", ['public','private','shared'], "Set the visibility tag (private, shared, public)") { |v|
        options[:visibility_tag] = v
      }
      parse_user(opt,options)
      parse_env_version(opt,options)
      opt.separator ""
      opt.separator "Advanced options:"
      opt.on("--toggle-destructive-tag ENVNAME", "Toggle the destructive tag on an environment") { |n|
        options[:env_name] = n
        options[:operation] = :'toggle-destructive-tag'
      }
      opt.on("--set-visibility-tag ENVNAME", "Set the visibility tag on an environment") { |n|
        options[:env_name] = n
        options[:operation] = :'set-visibility-tag'
      }
      opt.on("--update-image-checksum ENVNAME", "Update the checksum of the environment image") { |n|
        options[:env_name] = n
        options[:operation] = :'update-image-checksum'
      }
      opt.on("--update-preinstall-checksum ENVNAME", "Update the checksum of the environment preinstall") { |n|
        options[:env_name] = n
        options[:operation] = :'update-preinstall-checksum'
      }
      opt.on("--update-postinstalls-checksum ENVNAME", "Update the checksum of the environment postinstalls") { |n|
        options[:env_name] = n
        options[:operation] = :'update-postinstalls-checksum'
      }
      opt.on("--move-files", "Move the files of the environments (for administrators only)") { |n|
        options[:operation] = :'move-files'
      }
      parse_secure(opt,options)
    end
  end

  def self.check_options(options)
    case options[:operation]
    when :add
      if options[:env_desc].empty?
        error("You must choose a file that contains the environment description")
        return false
      end
    when :list

    when :delete, :print, :'update-image-checksum', :'update-preinstall-checksum', :'update-postinstalls-checksum', :'toggle-destructive-tag'
      if options[:env_name].empty?
        error("You must choose an environment")
        return false
      end
    when :'set-visibility-tag'
      if options[:env_name].empty?
        error("You must choose an environment")
        return false
      end
      if options[:visibility_tag].empty?
        error("You must define the visibility value")
        return false
      end
    when :'move-files'
      if options[:files_to_move].empty?
        error("You must define some files to move")
        return false
      end
    else
      error("You must choose an operation")
      return false
    end

    return true
  end

  def run(options)
    params = {
      :user => USER,
    }

    # set path
    path = api_path()
    if ![:add, :list, :'move-files'].include?(options[:operation])
      path = File.join(path,options[:user]||USER)
      path = File.join(path,options[:env_name]) if options[:env_name]
      path = File.join(path,options[:env_version]) if options[:env_version]
    elsif options[:operation] != :add
      path = File.join(path,options[:user]) if options[:user]
    end

    if [:add, :'update-image-checksum',:'update-postinstalls-checksum',:'update-preinstall-checksum',:'move-files'].include?(options[:operation])
      # Check if the environment contains local files
      desc = nil
      case options[:operation]
      when :add
        desc = options[:env_desc]
      when :'move-files'
        desc = options[:files_to_move].values
      else
        desc = get(path,params)[0]
      end
      localfiles = get_localfiles(desc)

      # Serve local files throught HTTP(s)
      params[:client] = http_export_files(localfiles,options[:secure]) unless localfiles.empty?
    end

    method = nil

    case options[:operation]
      when :add
        method = :POST
        params[:environment] = options[:env_desc]
      when :list
        method = :GET
      when :delete
        method = :DELETE
      when :print
        method = :GET
      when :'update-image-checksum'
        method = :PUT
        params[:update_image_checksum] = true
      when :'update-postinstalls-checksum'
        method = :PUT
        params[:update_postinstalls_checksum] = true
      when :'update-preinstall-checksum'
        method = :PUT
        params[:update_preinstall_checksum] = true
      when :'set-visibility-tag'
        method = :PUT
        params[:visibility] = options[:visibility_tag]
      when :'toggle-destructive-tag'
        method = :PUT
        params[:toggle_destructive] = true
      when :'move-files'
        method = :PUT
        params[:update_files] = options[:files_to_move]
      else
        raise
    end

    params[:last] = true unless options[:all_versions]

    ret = nil
    case method
      when :GET
        ret = get(path,params)
      when :POST
        ret = post(path,params)
      when :PUT
        ret = put(path,params)
      when :DELETE
        ret = delete(path,params)
      else
        raise
    end

    case options[:operation]
    when :list
      if ret.empty?
        debug 'No environment has been found'
      else
        print_headers()
        ret.each do |env|
          print_short(env)
        end
      end
    when :print
      if ret.empty?
        debug 'No environment has been found'
      else
        ret.each do |env|
          print_full(env)
        end
      end
    when :'move-files'
      ret.each{|env| debug "#{env['name']} v#{env['version']}"}
    end
  end
end

end

if __FILE__ == $0
  Kadeploy::KaenvsClient.launch()
end
