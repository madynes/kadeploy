#!/usr/bin/ruby -w

$kadeploy_libs=ENV['KADEPLOY3_LIBS']||'/usr/local/kadeploy3/src/lib'

$:.unshift($kadeploy_libs)

require 'optparse'
require 'yaml'
require 'client'

Signal.trap("INT") do
  puts "\nSIGINT trapped, let's clean everything ..."
  Kadeploy::KarebootClient.kill() rescue nil
  exit!(1)
end

module Kadeploy

class KarebootClient < ClientWorkflow
  def self.operation()
    'Reboot operation'
  end

  def self.load_options()
    {
      :operation => nil,
      :nodes => [],
      :env_name => nil,
      :env_version => nil, #By default we load the latest version
      :check_demolishing => false,
      :block_device => nil,
      :deploy_part => nil,
      :pxe_profile => nil,
      :pxe_files => [],
      :pxe_profile_singularities => nil,
      :key => nil,
      :nodes_ok_file => nil,
      :nodes_ko_file => nil,
      :level => :soft,
      :wait => true,
      :debug => false,
      :reboot_classical_timeout => nil,
      :vlan => nil,
      :verbose_level => nil,
      :debug => false,
      :get_version => false,
      :chosen_server => String.new,
      :servers => load_configfile(),
      :kadeploy_server => String.new,
      :kadeploy_server_port => String.new,
      :kadeploy_server_port => String.new,
    }
  end

  def self.parse_options()
    options = load_options()
    opts = OptionParser::new do |opt|
      opt.summary_indent = "  "
      opt.summary_width = 32
      opt.banner = "Usage: kareboot3 [options]"
      opt.separator "Contact: #{CONTACT_EMAIL}"
      opt.separator ""
      opt.separator "General options:"
      opt.on("-b", "--block-device BLOCKDEVICE", "Specify the block device to use") { |b|
        if /\A[\w\/]+\Z/ =~ b then
          options[:block_device] = b
        else
          error("Invalid block device")
          return false
        end
      }
      opt.on("-c", "--check-destructive-tag", "Check if some nodes was deployed with an environment that have the destructive tag") {
        options[:check_demolishing] = true
      }
      opt.on("-d", "--debug-mode", "Activate the debug mode") {
        options[:debug] = true
      }
      opt.on("-e", "--env-name ENVNAME", "Name of the recorded environment") { |n|
        options[:env_name] = n
      }
      opt.on("-f", "--file MACHINELIST", "Files containing list of nodes (- means stdin)")  { |f|
        load_machinefile(options[:nodes], f)
      }
      opt.on("-k", "--key [FILE]", "Public key to copy in the root's authorized_keys, if no argument is specified, use the authorized_keys") { |f|
        if (f != nil) then
          if (f =~ R_HTTP) then
            options[:key] = f
          else
            if not File.readable?(f) then
              error("The file #{f} cannot be read")
              return false
            else
              options[:key] = File.expand_path(f)
            end
          end
        else
          authorized_keys = File.expand_path("~/.ssh/authorized_keys")
          if File.readable?(authorized_keys) then
            options[:key] = authorized_keys
          else
            error("The authorized_keys file #{authorized_keys} cannot be read")
            return false
          end
        end
      }
      opt.on("-l", "--reboot-level VALUE", "Reboot level (soft, hard, very_hard)") { |l|
        if check_operation_level(l)
          options[:level] = l.downcase
        else
          error("Invalid level")
          return false
        end
      }
      opt.on("-m", "--machine MACHINE", "Reboot the given machines") { |hostname|
        load_machine(options[:nodes], hostname)
      }
      opt.on("--multi-server", "Activate the multi-server mode") {
        options[:multi_server] = true
      }
      opt.on("-n", "--output-ko-nodes FILENAME", "File that will contain the nodes not correctly rebooted")  { |f|
        options[:nodes_ko_file] = f
      }
      opt.on("-o", "--output-ok-nodes FILENAME", "File that will contain the nodes correctly rebooted")  { |f|
        options[:nodes_ok_file] = f
      }
      opt.on("-p", "--partition-number NUMBER", "Specify the partition number to use") { |p|
        options[:deploy_part] = p
      }
      opt.on("-r", "--reboot-kind REBOOT_KIND", "Specify the reboot kind (set_pxe, simple_reboot, deploy_env, env_recorded)") { |k|
        options[:operation] = k.strip.downcase.to_sym
      }
      opt.on("-u", "--user USERNAME", "Specify the user") { |u|
        if /\A\w+\Z/ =~ u then
          options[:user] = u
        else
          error("Invalid user name")
          return false
        end
      }
      opt.on("-v", "--version", "Get the version") {
        options[:get_version] = true
      }
      opt.on("--vlan VLANID", "Set the VLAN") { |id|
        options[:vlan] = id
      }
      opt.on("-w", "--set-pxe-profile FILE", "Set the PXE profile (use with caution)") { |f|
        unless File.readable?(f)
          error("The file #{f} cannot be read")
          return false
        else
          options[:pxe_profile] = File.read(f)
        end
      }
      opt.on("--set-pxe-pattern FILE", "Specify a file containing the substituation of a pattern for each node in the PXE profile (the NODE_SINGULARITY pattern must be used in the PXE profile)") { |f|
        if not File.readable?(f) then
          error("The file #{f} cannot be read")
          return false
        else
          options[:pxe_profile_singularities] = {}
          IO.readlines(f).each { |l|
            if !(/^#/ =~ l) and !(/^$/ =~ l) then #we ignore commented and empty lines
              content = l.split(",")
              options[:pxe_profile_singularities[content[0]]] = content[1].strip
            end
          }
        end
      }
      opt.on("-x", "--upload-pxe-files FILES", "Upload a list of files (file1,file2,file3) to the PXE kernels repository. Those files will then be available with the prefix FILES_PREFIX-- ") { |l|
        l.split(",").each { |file|
          if (file =~ R_HTTP) then
            options[:pxe_files] << file
          else
            f = File.expand_path(file)
            if not File.readable?(f) then
              error("The file #{f} cannot be read")
              return false
            else
              options[:pxe_files] << (f)
            end
          end
        }
      }
      opt.on("--env-version NUMBER", "Specify the environment version") { |v|
        if /\A\d+\Z/ =~ v then
          options[:env_version] = v
        else
          error("Invalid version number")
          return false
        end
      }
      opt.on("--no-wait", "Do not wait the end of the reboot") {
        options[:wait] = false
      }
      opt.on("--server STRING", "Specify the Kadeploy server to use") { |s|
        options[:chosen_server] = s
      }
      opt.on("-V", "--verbose-level VALUE", "Verbose level between 0 to 5") { |d|
        begin
          options[:verbose_level] = d.to_i
        rescue
          error("Invalid verbose level")
          return false
        end
      }
      opt.on("--reboot-classical-timeout V", "Overload the default timeout for classical reboots") { |t|
        if (t =~ /\A\d+\Z/) then
          options[:reboot_classical_timeout] = t
        else
          error("A number is required for the reboot classical timeout")
        end
      }
    end

    begin
      opts.parse!(ARGV)
    rescue
      error("Option parsing error: #{$!}")
      return false
    end

    options[:chosen_server] = options[:servers]['default'] if options[:chosen_server].empty?
    options[:kadeploy_server] = options[:servers][options[:chosen_server]][0]
    options[:kadeploy_server_port] = options[:servers][options[:chosen_server]][1]

    return options
  end

  def self.check_options(options)
    if options[:nodes].empty?
      error("No node is chosen")
      return false
    end
    unless (1..5).include?(options[:verbose_level])
      error("Invalid verbose level")
      return false
    end
    if !options[:operation] or options[:operation].empty?
      error("No operation is chosen")
      return false
    end

    case options[:operation]
    when :set_pxe
      if !options[:pxe_profile] or options[:pxe_profile].empty?
        error("The set_pxe reboot must be used with the -w option")
        return false
      end
    when :env_recorded
      if !options[:env_name] or options[:env_name].empty?
        error("An environment must be specified must be with the env_recorded kind of reboot")
        return false
      end
      unless options[:deploy_part]
        error("A partition number must be specified must be with the env_recorded kind of reboot")
        return false
      end
    end

    if options[:key] and options[:operation] != :deploy_env
      error("The -k option can be only used with the deploy_env reboot kind")
      return false
    end

    if options[:nodes_ok_file] and options[:nodes_ok_file] == options[:nodes_ko_file]
      error("The files used for the output of the OK and the KO nodes cannot be the same")
      return false
    end

    unless options[:wait]
      if options[:nodes_ok_file] or options[:nodes_ko_file]
        error("-o/--output-ok-nodes and/or -n/--output-ko-nodes cannot be used with --no-wait")
        return false
      end
      if options[:key]
        error("-k/--key cannot be used with --no-wait")
        return false
      end
    end

    true
  end

  def run(options)
    raise 'Not implemented yet !'
  end
end

end

if __FILE__ == $0
  Kadeploy::KarebootClient.launch()
end

