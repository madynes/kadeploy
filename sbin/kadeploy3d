#!/usr/bin/ruby -w

# Kadeploy 3.1
# Copyright (c) by INRIA, Emmanuel Jeanvoine - 2008-2012
# CECILL License V2 - http://www.cecill.info
# For details on use and redistribution please refer to License.txt

$kadeploy_logdir=ENV['KADEPLOY3_LOGDIR']||'/var/log/kadeploy'
$kadeploy_logfiles = {}
$kadeploy_libs=ENV['KADEPLOY3_LIBS']||'/usr/local/kadeploy3/src/lib'
$kadeploy_config_directory=ENV['KADEPLOY3_CONFIG_DIR']||'/etc/kadeploy3'

SSH_KEY=File.join($kadeploy_config_directory,'keys/id_deploy')

LOGFILE_HTTPD='httpd.log'
LOGFILE_ACCESS='access.log'
LOGFILE_DEBUG='debug.log'
LOGFILE_ERROR='error.log'

$:.unshift($kadeploy_libs)


Signal::trap("INT") do
  puts "\nSIGINT trapped, let's clean everything ..."
  $kadeploy.kill()
  $httpd.shutdown
  clean()
  exit!(1)
end

Signal::trap("TERM") do
  puts "\nSIGINT trapped, let's clean everything ..."
  $kadeploy.kill()
  $httpd.shutdown
  clean()
  exit!(1)
end

# Reload the service & logfiles rotation (syslogd)
Signal::trap("HUP") do
  $kadeploy_logfiles.each_value do |io|
    if io
      filename = File.readlink(File.join("/proc/self/fd/#{io.fileno}"))
      io.reopen(filename,'a+')
    end
  end
end


require 'webrick'
require 'webrick/https'
require 'socket'
require 'fileutils'
require 'json'
require 'optparse'

require 'server'
require 'config'

include WEBrick


def clean()
  FileUtils::remove_entry($httpd_directory) if $httpd_directory
  $kadeploy_logfiles.each_value do |io|
    io.close if io and !io.closed?
  end
  if $ssh_key
    ENV['SSH_AGENT_PID'] = $ssh_agent_pid
    ENV['SSH_AUTH_SOCK'] = $ssh_agent_sock
    `ssh-agent -k`
  end
end

def error(msg='',abrt = true)
  $stderr.puts msg if msg and !msg.empty?
  clean() if abrt
  exit 1 if abrt
end

$ssh_key = nil
$pidfile = nil

# Parse options
OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]\n!!! Be careful, the daemon is not launched as root !!!"

  opts.on("", "--pidfile FILE", "Write the pid of the daemon process in a file") do |p|
    $pidfile = p
  end

  opts.on("", "--agent-key SSH_KEY_FILE", "The ssh key file to be add to the SSH agent") do |a|
    $ssh_key = a
  end
end.parse!


# Check logs directory
if !File.directory?($kadeploy_logdir)
  error("Log directory '#{$kadeploy_logdir}' does not exists")
end

if !File.writable?($kadeploy_logdir)
  error("Log directory '#{$kadeploy_logdir}' not writable")
end

# Loading SSH agent
if $ssh_key
  error("Unable to read the SSH key file '#{$ssh_key}'") unless File.readable?($ssh_key)
else
  $ssh_key = SSH_KEY if File.readable?(SSH_KEY)
end

if $ssh_key
  tmp=`eval $(ssh-agent) >/dev/null && echo $SSH_AGENT_PID $SSH_AUTH_SOCK`.strip.split(' ')
  $ssh_agent_pid = tmp[0]
  ENV['SSH_AGENT_PID'] = $ssh_agent_pid
  $ssh_agent_sock = tmp[1]
  ENV['SSH_AUTH_SOCK'] = $ssh_agent_sock
  `ssh-add #{$ssh_key}`
  $stdout.puts "SSH-agent #{$ssh_agent_pid} loaded"
end


# Disable reverse lookup to prevent lag in case of DNS failure
Socket::do_not_reverse_lookup = true

# Load the configuration
$kadeploy = KadeployServer.new()
$stdout.puts 'Configuration files loaded'

# Prepare to launch HTTPd
$httpd_directory = Dir::mktmpdir('katmp')

begin
  $kadeploy_logfiles[:httpd] = File.open(
      File.join($kadeploy_logdir,LOGFILE_HTTPD), 'a+')

  $kadeploy_logfiles[:access] = File.open(
      File.join($kadeploy_logdir,LOGFILE_ACCESS), 'a+')
  $kadeploy_logfiles[:access].sync = true

  $stderr = $stdout
  $httpd = HTTPServer.new(
    :Port=>$kadeploy.port,
    :DocumentRoot=>$httpd_directory,
    :SSLEnable => true,
    :SSLCertName => [['CN',$kadeploy.host]],
    :SSLVerifyClient  => OpenSSL::SSL::VERIFY_NONE,
    :Logger => WEBrick::Log.new($kadeploy_logfiles[:httpd]),
    :AccessLog => [
      [
        $kadeploy_logfiles[:access],
        WEBrick::AccessLog::COMMON_LOG_FORMAT
      ]
    ]
  )
  $stderr = STDERR
rescue Errno::EADDRINUSE
  error("Another service is listening on the port #{$kadeploy.port}")
  exit 1
end


# Configure HTTPd bindings
$kadeploy.config_httpd($httpd)


# Demonize the process
exit 0 if fork
Process::setsid

# Redirecting outputs to logfiles
STDIN::reopen('/dev/null')

STDOUT::reopen(File.join($kadeploy_logdir,LOGFILE_DEBUG), 'a+')
STDOUT::sync = true
$kadeploy_logfiles[:debug] = STDOUT
$stdout = STDOUT

STDERR::reopen(File.join($kadeploy_logdir,LOGFILE_ERROR), 'a+')
#STDOUT::sync = true
$kadeploy_logfiles[:error] = STDERR
$stderr = STDERR

File.open($pidfile,'w'){|f| f.puts Process::pid} if $pidfile

$stdout.puts "[#{Time.now.to_s}] Launching service"

# Launch HTTPd
$httpd.start
clean()

