#!/usr/bin/ruby -w
$:.unshift(ENV['KADEPLOY3_LIBS']) if ENV['KADEPLOY3_LIBS']
$kadeploy_logdir=ENV['KADEPLOY3_LOG_DIR']||'/var/log/kadeploy3'
$kadeploy_rundir=ENV['KADEPLOY3_RUN_DIR']||'/var/run/kadeploy3d'
$kadeploy_confdir=ENV['KADEPLOY3_CONFIG_DIR']||'/etc/kadeploy3'
$kadeploy_logfiles = {}

SSH_KEY=File.join($kadeploy_confdir,'keys/id_deploy')

LOGFILE_DEBUG='output.log'
LOGFILE_ERROR='error.log'
RUNFILE_RELOAD='reload'

AUTOCLEAN_PITCH = 300

$version = nil
$autoclean = nil
$kadeploy = nil
$httpd = nil

Signal::trap("INT") do
  puts "\nSIGINT trapped, let's clean everything ..."
  $autoclean.kill() if $autoclean
  $kadeploy.kill() if $kadeploy
  $httpd.kill() if $httpd
  clean()
  exit!(1)
end

Signal::trap("TERM") do
  puts "\nSIGINT trapped, let's clean everything ..."
  $autoclean.kill() if $autoclean
  $kadeploy.kill() if $kadeploy
  $httpd.kill() if $httpd
  clean()
  exit!(1)
end

#require 'stringio'

# Reload the service & logfiles rotation (syslogd)
Signal::trap("HUP") do
  # The launcher will read the file RUNFILE_RELOAD to know if the reload operation was successful
  # In this file, the first line is the return code (0 if successfull)
  # The following lines are representing the error message if there is an error
  stderr = $stderr
  $stderr = StringIO.new
  # The config parser writes error messages on $stderr, since we want to
  # write the return code as the first line of the reload file, and since
  # to know if there is an error or not we have to launch the config parser,
  # we cant redirect $stderr to the reload file directly
  # That's why we are using a StringIO object in order to be able to store the
  # error message that are written on $stderr and then write this message in the
  # reload file AFTER the return code

  $kadeploy_logfiles.each_value do |io|
    if io
      filename = File.readlink(File.join("/proc/self/fd/#{io.fileno}"))
      io.reopen(filename,'a+')
    end
  end
  file = File.open(File.join($kadeploy_rundir,RUNFILE_RELOAD),'w+')
  begin
    STDOUT.puts "[#{Time.now.to_s}] Reloading configuration files"
    $kadeploy.reload_config()
    file.puts '0'
  rescue Exception => e
    STDERR.puts "[#{Time.now.to_s}] Failed to reload configuration files !"
    if e.is_a?(Kadeploy::KadeployError)
      file.puts '1'
      error("#{Kadeploy::KadeployError.to_msg(e.errno)}"\
        "#{(e.message and !e.message.empty? ? ': ' + e.message : '')}",false)
    else
      file.puts '2'
      error(e.message,false)
    end
    file.write($stderr.string)
  ensure
    file.close unless file.closed?
    $stderr.close unless $stderr.closed?
    $stderr = stderr
  end
end


require 'kadeploy3/server'

require 'thread'
require 'fileutils'
require 'json'
require 'optparse'


def clean()
  $kadeploy_logfiles.each_value do |io|
    io.close if io and !io.closed?
  end
  if $ssh_key
    ENV['SSH_AGENT_PID'] = $ssh_agent_pid
    ENV['SSH_AUTH_SOCK'] = $ssh_agent_sock
    `ssh-agent -k`
  end
end

def error(msg='',abrt = true)
  $stderr.puts msg if msg and !msg.empty?
  clean() if abrt
  exit 1 if abrt
end


$ssh_key = nil
$pidfile = nil
$detach = false
$redirect_stdin = true
$redirect_stdout = true
$redirect_stderr = true
$generate_dh_seeds = true


# Parse options
OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]\n!!! Be careful, the daemon is not launched as root !!!"

  opts.on("-p", "--pidfile FILE", "Write the pid of the daemon process in a file") do |p|
    $pidfile = p
  end

  opts.on("-k", "--agent-key SSH_KEY_FILE", "The ssh key file to be add to the SSH agent") do |a|
    $ssh_key = a
  end

  opts.on("-d", "--detach", "Run the application in background") do
    $detach = true
  end

  opts.on("-I", "--no-stdin-pipe", "Do not pipe /dev/null to stdin") do
    $redirect_stdin = false
  end

  opts.on("-O", "--no-stdout-redirect", "Do not redirect stdout to a logfile") do
    $redirect_stdout = false
  end

  opts.on("-E", "--no-stderr-redirect", "Do not redirect stderr to a logfile") do
    $redirect_stderr = false
  end

  opts.on("-S", "--no-dh-seeds", "Do not generate seeds for DH algorithm (use default ones)") do
    $generate_dh_seeds = false
  end

  opts.on("--ruby-debug", "Run with ruby interpreter's debug mode") do
    $DEBUG = true
  end

  opts.on("-v", "--version", "Display the version of the service") do
    $version = true
  end
end.parse!

if $version
  if ENV['KADEPLOY3_VERSION']
    $stdout.puts ENV['KADEPLOY3_VERSION']
    exit 0
  else
    version_file = File.join($kadeploy_confdir,'version')
    if File.readable?(version_file)
      $stdout.puts File.read(version_file).strip
      exit 0
    else
      $stderr.puts "cannot read the file '#{version_file}'"
      exit 1
    end
  end
end


# Check logs directory
if !File.directory?($kadeploy_logdir)
  error("Log directory '#{$kadeploy_logdir}' does not exists")
end

if (!File.writable?(File.join($kadeploy_logdir,LOGFILE_DEBUG)) \
    or !File.writable?(File.join($kadeploy_logdir,LOGFILE_ERROR))) \
  and !File.writable?($kadeploy_logdir)
  error("Log directory '#{$kadeploy_logdir}' not writable")
end

# Loading SSH agent
if $ssh_key
  error("Unable to read the SSH key file '#{$ssh_key}'") unless File.readable?($ssh_key)
else
  $ssh_key = SSH_KEY if File.readable?(SSH_KEY)
end

if $ssh_key
  tmp=`eval $(ssh-agent) >/dev/null && echo $SSH_AGENT_PID $SSH_AUTH_SOCK`.strip.split(' ')
  error('Unable to run ssh-agent') unless $?.success?
  $ssh_agent_pid = tmp[0]
  ENV['SSH_AGENT_PID'] = $ssh_agent_pid
  $ssh_agent_sock = tmp[1]
  ENV['SSH_AUTH_SOCK'] = $ssh_agent_sock
  `ssh-add #{$ssh_key} 2>/dev/null`
  error('Unable to add the key to the ssh-agent') unless $?.success?
  $stdout.puts "SSH-agent #{$ssh_agent_pid} loaded"
end


# Disable reverse lookup to prevent lag in case of DNS failure
Socket::do_not_reverse_lookup = true

# Load the configuration
begin
  $kadeploy = Kadeploy::KadeployServer.new()
rescue Kadeploy::KadeployError => ke
  error("#{Kadeploy::KadeployError.to_msg(ke.errno)}"\
    "#{(ke.message and !ke.message.empty? ? ': ' + ke.message : '')}")
end
$stdout.puts 'Configuration files loaded'

dh_seeds = nil
if $kadeploy.secure and $generate_dh_seeds
  $stdout.puts 'Generate seeds for DH algorithm'
  dh_seeds = {
    512 => OpenSSL::PKey::DH.new(512),
    1024 => OpenSSL::PKey::DH.new(1024),
  }
end

# Prepare to launch HTTPd
begin
  $stderr = $stdout
  $httpd = Kadeploy::HTTPd::Server.new($kadeploy.host,$kadeploy.port,
    $kadeploy.secure,$kadeploy.cert,$kadeploy.private_key,dh_seeds)
  $stderr = STDERR

  $kadeploy_logfiles[:httpd] = $httpd.logs[:httpd]
  $kadeploy_logfiles[:access] = $httpd.logs[:access]

rescue Errno::EADDRINUSE
  error("Another service is listening on the port #{$kadeploy.port}")
  exit 1
end


# Configure HTTPd bindings
$kadeploy.config_httpd_bindings($httpd)


# Demonize the process
if $detach
  exit 0 if fork
  Process::setsid
end

# Pipe /dev/null to stdin
STDIN::reopen('/dev/null') if $redirect_stdin

# Redirecting outputs to logfiles
if $redirect_stdout
  STDOUT::reopen(File.join($kadeploy_logdir,LOGFILE_DEBUG), 'a+')
  STDOUT::sync = true
  $kadeploy_logfiles[:debug] = STDOUT
end
$stdout = STDOUT

if $redirect_stderr
  STDERR::reopen(File.join($kadeploy_logdir,LOGFILE_ERROR), 'a+')
  #STDOUT::sync = true
  $kadeploy_logfiles[:error] = STDERR
end
$stderr = STDERR

File.open($pidfile,'w'){|f| f.puts Process::pid} if $pidfile

$stdout.puts "[#{Time.now.to_s}] Launching service"

# Launch autoclean thread
$autoclean = Thread.new do
  begin
    sleep AUTOCLEAN_PITCH
    $kadeploy.workflows_clean()
  end while true
end

GC.start

# Launch HTTPd
$httpd.run()
clean()

