#!/usr/bin/ruby

require 'rubygems'
require 'net/ssh/gateway'
require 'net/ssh/multi'
require 'restclient'
require 'json'
require 'tempfile'
require 'ipaddr'
require 'yaml'
require 'uri'
require 'resolv'
require 'optparse'


def g5k?
  `hostname --fqdn`.chomp =~ /grid5000.fr$/
end

USAGE           = "Usage: #{$0} [options] <deploykernels_directory> <envs_directory>"

SSH_KEYS        = ["#{ENV['HOME']}/.ssh/id_dsa", "#{ENV['HOME']}/.ssh/id_rsa","#{ENV['HOME']}/.ssh/identity"]
SSH_OPTIONS			= '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o PreferredAuthentications=publickey'
HTTP_PROXY_ADDR   = 'proxy'
HTTP_PROXY_PORT   = 3128
DEB_REPOSITORY   	= 'http://apt.grid5000.fr/kadeploy'

if g5k?
  G5K_API       	= 'https://api.grid5000.fr/2.0'
  G5K_POSTINSTALLS_PATH = '/grid5000/preinstalls/'
else
end

DOMAIN = 'testbed.lan'
CLUSTER_NAME_SUFIX = '-cluster'
NODE_NAME_PREFIX = 'node-'
HOST_NAME_PREFIX = 'host-'

NET_ADMIN_IFACE = 'eth0'
USE_NET_DRIVER = false
USE_DISK_DRIVER = false

KVM_GATEWAY = '192.168.0.254'
# used to get kadeploy debian package on g5k
KVM_G5K_USER = 'lsarzyniec'
KVM_G5K_SITE = 'access.nancy.grid5000.fr'
KVM_PACKAGES = [ 'kvm', 'qemu', 'qemu-kvm' , 'bridge-utils' ]
KVM_BRIDGE_DEV = 'br0'

DEFAULT_CONSOLE_BAUD_RATE = '38400'
DEFAULT_CONSOLE_TTY_ID = '0'
DEFAULT_RAMDISK_SIZE = 290000

# Used when can't auto detect
DEFAULT_NET_DRIVER = 'e1000e'
DEFAULT_DISK_DRIVER = 'scsi_mod'

# Update path for devel
UPDATE_PATH_CHECK = {
  'src' => 'kadeploy_server.rb',
  'lib' => 'managers.rb',
}
UPDATE_FORWARD_PORT = 2222
UPDATE_DIR_VAR = 'WORKINGDIR'


# Kadeploy default config
CFG_KADEPLOY_USER = 'deploy'

CFG_KADEPLOY_MACROSTEP1 = {
  :name => 'SetDeploymentEnv|SetDeploymentEnvUntrusted',
  :retries => 2,
  :timeout => 450
}
CFG_KADEPLOY_MACROSTEP2 = {
  :name => 'BroadcastEnv|BroadcastEnvKastafior',
  :retries => 1,
  :timeout => 900
}
CFG_KADEPLOY_MACROSTEP3 = [
  {
    :name => 'BootNewEnv|BootNewEnvClassical',
    :retries => 1,
    :timeout => 400
  },
  {
    :name => 'BootNewEnvHardReboot',
    :retries => 1,
    :timeout => 400
  }
]

CFG_KADEPLOY_PARTITION_SWAP_ID = 3
CFG_KADEPLOY_PARTITION_SWAP_SIZE = '512M'
CFG_KADEPLOY_PARTITION_PROD_ID = 1
CFG_KADEPLOY_PARTITION_PROD_SIZE = '128M'
CFG_KADEPLOY_PARTITION_DEPLOY_ID = 2
CFG_KADEPLOY_PARTITION_DEPLOY_SIZE = '3000M'
CFG_KADEPLOY_PARTITION_TMP_ID = 4
CFG_KADEPLOY_DISK_DEVICE = '/dev/sda'

CFG_KADEPLOY_PORT = 25300
CFG_KADEPLOY_VERBOSE = 3
CFG_KADEPLOY_CONF_PATH = '/etc/kadeploy3'
CFG_KADEPLOY_VAR_PATH = '/var/lib/kadeploy'
CFG_KADEPLOY_LOGFILE = '/var/log/kadeploy.log'
CFG_KADEPLOY_SSHKEY_PATH = File.join(CFG_KADEPLOY_CONF_PATH,'keys')
CFG_KADEPLOY_SSHKEY_DEFAULT = File.join(CFG_KADEPLOY_SSHKEY_PATH,'id_deploy')
CFG_KADEPLOY_HOSTNAMES_PATH = File.join(CFG_KADEPLOY_VAR_PATH,'hostnames')
CFG_KADEPLOY_KVM_PROCS_PATH = File.join(CFG_KADEPLOY_VAR_PATH,'kvmprocs')
CFG_KADEPLOY_KVM_HOSTS_PATH = File.join(CFG_KADEPLOY_VAR_PATH,'kvmhosts')
CFG_KADEPLOY_HOSTNAMES_SSHKEY = File.join(CFG_KADEPLOY_HOSTNAMES_PATH,'.ssh_key')
CFG_KADEPLOY_ENVS_PATH = File.join(CFG_KADEPLOY_VAR_PATH,'envs')
CFG_KADEPLOY_ENVS_IMAGES_PATH = File.join(CFG_KADEPLOY_ENVS_PATH,'images')
CFG_KADEPLOY_ENVS_DESC_PATH = File.join(CFG_KADEPLOY_ENVS_PATH,'descriptions')
CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH = File.join(CFG_KADEPLOY_ENVS_PATH,'install_scripts')
CFG_KADEPLOY_CACHE_PATH = '/var/cache/kadeploy/cache'
CFG_KADEPLOY_PREINSTALLS_PATH = File.join(CFG_KADEPLOY_VAR_PATH,'preinstalls')

def cfg_environment_desc(env)
  postinstall = ''
  if env[:postinstall]
    postinstall = "postinstall : #{File.join(CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH,File.basename(env[:postinstall][:file]))}|#{env[:postinstall][:filetype]}|#{env[:postinstall][:args]}\n"
  end

  "###\n"\
  "name : #{env[:name]}\n"\
  "#{env[:desc]}\n"\
  "tarball : #{File.join(CFG_KADEPLOY_ENVS_IMAGES_PATH,File.basename(env[:tarball]))}|tgz\n"\
  + postinstall
end

CFG_KADEPLOY_CLIENT_CONF_FILE = File.join(CFG_KADEPLOY_CONF_PATH,'client_conf')
def cfg_kadeploy_client()
  "default = kadeploy\n"\
  "kadeploy = #{$kanodes[:kadeploy][:fqdn]}:#{CFG_KADEPLOY_PORT}\n"
end


def cfg_kadeploy_macrostep(macrostep)
  ret = ''
  if macrostep.is_a?(Array)
    tmp = []
    macrostep.each do |step|
      tmp << cfg_kadeploy_macrostep(step)
      ret = tmp.join(',')
    end
  elsif macrostep.is_a?(Hash)
    ret = "#{macrostep[:name]}:#{macrostep[:retries]}:#{macrostep[:timeout]}"
  elsif macrostep.is_a?(String)
    ret = macrostep
  end
  ret
end

CFG_KADEPLOY_CONF_CONF_FILE = File.join(CFG_KADEPLOY_CONF_PATH,'conf')
def cfg_kadeploy_conf()
  "verbose_level = #{CFG_KADEPLOY_VERBOSE}\n"\
  "tftp_repository = #{CFG_TFTP_PATH}\n"\
  "tftp_images_path = #{CFG_TFTP_KERNELS_DIR}\n"\
  "tftp_images_max_size = 600\n"\
  "tftp_cfg = #{CFG_TFTP_PXECONFIG_DIR}\n"\
  "db_kind = mysql\n"\
  "deploy_db_host = #{$kanodes[:sql][:fqdn]}\n"\
  "deploy_db_name = #{CFG_SQL_DB}\n"\
  "deploy_db_login = #{CFG_SQL_USER}\n"\
  "deploy_db_passwd = #{CFG_SQL_PASS_USER}\n"\
  "rights_kind = db\n"\
  "taktuk_connector = ssh -q #{SSH_OPTIONS} -o BatchMode=yes -i #{CFG_KADEPLOY_SSHKEY_DEFAULT} -l root\n"\
  "taktuk_tree_arity = 0\n"\
  "taktuk_auto_propagate = true\n"\
  "tarball_dest_dir = /tmp\n"\
  "environment_extraction_dir = /mnt/dest\n"\
  "kadeploy_server = #{$kanodes[:kadeploy][:fqdn]}\n"\
  "kadeploy_server_port = #{CFG_KADEPLOY_PORT}\n"\
  "kadeploy_tcp_buffer_size = 8192\n"\
  "kadeploy_cache_dir = #{CFG_KADEPLOY_CACHE_PATH}\n"\
  "kadeploy_cache_size = 8000\n"\
  "ssh_port = 22\n"\
  "rsh_port = 514\n"\
  "test_deploy_env_port = #{CFG_KADEPLOY_PORT}\n"\
  "use_rsh_to_deploy = false\n"\
  "log_to_file = #{CFG_KADEPLOY_LOGFILE}\n"\
  "log_to_syslog = true\n"\
  "log_to_db = true\n"\
  "dbg_to_syslog = true\n"\
  "dbg_to_syslog_level = 3\n"\
  "reboot_window = 200\n"\
  "reboot_window_sleep_time = 8\n"\
  "nodes_check_window = 100\n"\
  "bootloader = chainload_pxe\n"\
  "purge_deployment_timer = 900\n"\
  "rambin_path = /rambin\n"\
  "mkfs_options = ext2@-b 4096 -O sparse_super,filetype,resize_inode,dir_index|ext3@-b 4096 -O sparse_super,filetype,resize_inode,dir_index\n"\
  "demolishing_env_threshold = 2\n"\
  "demolishing_env_auto_tag = false\n"\
  "bt_download_timeout = 1800\n"\
  "almighty_env_users = root,oar,deploy\n"\
  "max_preinstall_size = 10\n"\
  "max_postinstall_size = 10\n"\
  "vlan_hostname_suffix = -kavlan-VLAN_ID\n"
  #"async_end_of_deployment_hook = \n"\
  #"set_vlan_cmd = \n"
  # >>> TODO: add Bitorrent support in bootstrap
  #"bt_tracker_ip = \n"\
end

CFG_KADEPLOY_CMD_CONF_FILE = File.join(CFG_KADEPLOY_CONF_PATH,'cmd')
def cfg_kadeploy_cmd()
  "\n"
end

CFG_KADEPLOY_CLUSTERS_CONF_FILE = File.join(CFG_KADEPLOY_CONF_PATH,'clusters')
def cfg_kadeploy_clusters()
  cfg = ''
  $clusters.values.each do |cluster|
    cfg += "#{cluster[:name]}\n"
  end
  cfg
end

CFG_KADEPLOY_NODES_CONF_FILE = File.join(CFG_KADEPLOY_CONF_PATH,'nodes')
def cfg_kadeploy_nodes()
  nodescfg = ''
  select_type($kanodes,:NODE).each do |node|
    nodescfg += "#{node[:fqdn]} #{node[:ipv4]} #{node[:cluster][:name]}\n"
  end
  nodescfg
end

CFG_KADEPLOY_PARTITION_CONF_FILE_PREFIX = File.join(CFG_KADEPLOY_CONF_PATH,'partition_file_')
def cfg_kadeploy_partition_file(cluster)
  # delete partitions
  "d\n1\nd\n2\nd\n3\nd\n4\n"\
  + # create prod partition
  "n\np\n#{CFG_KADEPLOY_PARTITION_PROD_ID}\n\n+#{CFG_KADEPLOY_PARTITION_PROD_SIZE}\nt\n83\n"\
  + # create deploy partition
  "n\np\n#{CFG_KADEPLOY_PARTITION_DEPLOY_ID}\n\n+#{CFG_KADEPLOY_PARTITION_DEPLOY_SIZE}\nt\n#{CFG_KADEPLOY_PARTITION_DEPLOY_ID}\nPARTTYPE\n"\
  + # create swap partition
  "n\np\n#{CFG_KADEPLOY_PARTITION_SWAP_ID}\n\n+#{CFG_KADEPLOY_PARTITION_SWAP_SIZE}\nt\n#{CFG_KADEPLOY_PARTITION_SWAP_ID}\n82\n"\
  + # create tmp partition
  "n\np\n\n\nt\n#{CFG_KADEPLOY_PARTITION_TMP_ID}\n83\n"\
  + # write changes
  "w\n"\
  "\n"
end

def cfg_kadeploy_specific_conf_postinstall_path(cluster)
  postinstall = nil
  if cluster[:postinstall]
    postinstall = File.join(CFG_KADEPLOY_PREINSTALLS_PATH,"postinstall-#{cluster[:name]}.tgz")
  end
  postinstall
end

def cfg_kadeploy_kapower_cmd(cmd)
  "ssh #{SSH_OPTIONS} -i #{CFG_KADEPLOY_HOSTNAMES_SSHKEY} #{ENV['USER']}@#{getgw()} \"kapower3 -m `cat #{File.join(CFG_KADEPLOY_HOSTNAMES_PATH,'HOSTNAME_FQDN')}` #{cmd}\""
end

def cfg_kadeploy_kaconsole_cmd(user=ENV['USER'])
  "ssh -t #{SSH_OPTIONS} -i #{CFG_KADEPLOY_HOSTNAMES_SSHKEY} #{user}@#{getgw()} \"kaconsole3 -m `cat #{File.join(CFG_KADEPLOY_HOSTNAMES_PATH,'HOSTNAME_FQDN')}`\""
end


def cfg_kadeploy_kvm_cmd(cmd,user='root')
  host = nil
	case $mode
		when :VLANKVM
      host = "`cat #{File.join(CFG_KADEPLOY_KVM_HOSTS_PATH,'HOSTNAME_FQDN')}`"
		when :KVM
      host = getgw()
		else
			msg('Invalid mode',MSG_ERROR,true)
	end
  "ssh #{SSH_OPTIONS} -i #{CFG_KADEPLOY_HOSTNAMES_SSHKEY} "\
  "#{user}@#{host} \"#{cmd}\""
end

def cfg_kadeploy_kvm_ps()
  "ps -e -f --sort=+pid | grep kvm | grep -v grep "\
  "| grep '\\-name `cat #{File.join(CFG_KADEPLOY_HOSTNAMES_PATH,'HOSTNAME_FQDN')}`'"\
  " | head -n 1 | sed \'s/[ \\t]\\+/ /g\' | sed \'s/^[ \\t]\\+//g\' "\
end

def cfg_kadeploy_kvm_procs_cache_update(override=false)
  if override
    ret = ''
  else
    ret = "test -f #{File.join(CFG_KADEPLOY_KVM_PROCS_PATH,'HOSTNAME_FQDN')} || "
  end

  "#{ret}#{cfg_kadeploy_kvm_cmd(cfg_kadeploy_kvm_ps())} "\
  "> #{File.join(CFG_KADEPLOY_KVM_PROCS_PATH,'HOSTNAME_FQDN')}"
end

def cfg_kadeploy_kvm_procs_get()
  "#{cfg_kadeploy_kvm_procs_cache_update()}; "\
  "cat #{File.join(CFG_KADEPLOY_KVM_PROCS_PATH,'HOSTNAME_FQDN')}"
end

def cfg_kadeploy_kvm_procs_get_pid()
  "#{cfg_kadeploy_kvm_procs_get()} | cut -f 2 -d' '"
end

def cfg_kadeploy_kvm_procs_get_params()
  "#{cfg_kadeploy_kvm_procs_get()} | cut -f 8- -d' ' | sed -e 's/^SCREEN/screen/g'"
end

def cfg_kadeploy_power_on_cmd()
  ret = ''
	case $mode
		when :KAVLAN
      ret = cfg_kadeploy_kapower_cmd('--on')
		when :KVM, :VLANKVM
      ret = "#{cfg_kadeploy_kvm_cmd("$(#{cfg_kadeploy_kvm_procs_get_params()}) &>/dev/null &")} "\
        "&& #{cfg_kadeploy_kvm_procs_cache_update(true)}"
		else
			msg('Unknown mode',MSG_ERROR,true)
	end
  ret
end

def cfg_kadeploy_power_off_cmd()
  ret = ''
	case $mode
		when :KAVLAN
      ret = cfg_kadeploy_kapower_cmd('--off')
		when :KVM, :VLANKVM
      ret = "#{cfg_kadeploy_kvm_cmd("kill $(#{cfg_kadeploy_kvm_procs_get_pid()}) &>/dev/null")}"
		else
			msg('Unknown mode',MSG_ERROR,true)
	end
  ret
end

def cfg_kadeploy_power_status_cmd()
  ret = ''
	case $mode
		when :KAVLAN
      ret = cfg_kadeploy_kapower_cmd('--status')
		when :KVM, :VLANKVM
      ret = "test -n \"$(#{cfg_kadeploy_kvm_procs_get()})\" "\
       "&& echo HOSTNAME_FQDN : ON "\
       "|| echo HOSTNAME_FQDN : OFF"
		else
			msg('Unknown mode',MSG_ERROR,true)
	end
  ret
end

def cfg_kadeploy_console_cmd()
  ret = ''
	case $mode
		when :KAVLAN
      ret = cfg_kadeploy_kaconsole_cmd()
		when :KVM, :VLANKVM
      ret = "ssh -t #{SSH_OPTIONS} -i #{CFG_KADEPLOY_HOSTNAMES_SSHKEY} root@HOSTNAME_FQDN"
		else
			msg('Unknown mode',MSG_ERROR,true)
	end
  ret
end

def cfg_kadeploy_reboot_cmd()
  "#{cfg_kadeploy_power_off_cmd()} && #{cfg_kadeploy_power_on_cmd()}"
end

def cfg_kadeploy_disk_device()
  CFG_KADEPLOY_DISK_DEVICE
end

def cfg_kadeploy_deploy_kernel_imgpath(cluster)
  ret = ''
	case $deploysendmeth
		when :HTTP
      ret = "http://#{$kanodes[:www][:ipv4]}/#{File.join(CFG_HTTP_KERNELS_PATH,File.basename(cluster[:kernel][:vmlinuz]))}"
		when :TFTP
      ret = File.basename(cluster[:kernel][:vmlinuz])
		else
			msg('Unknown deploy env sending method',MSG_ERROR,true)
	end
  ret
end

def cfg_kadeploy_deploy_kernel(cluster)
  "#{cfg_kadeploy_deploy_kernel_imgpath(cluster)}"
end

def cfg_kadeploy_deploy_initrd_imgpath(cluster)
  ret = ''
	case $deploysendmeth
		when :HTTP
      ret = "http://#{$kanodes[:www][:ipv4]}/#{File.join(CFG_HTTP_KERNELS_PATH,File.basename(cluster[:kernel][:initrd]))}"
		when :TFTP
      ret = File.basename(cluster[:kernel][:initrd])
		else
			msg('Unknown deploy env sending method',MSG_ERROR,true)
	end
  ret
end

def cfg_kadeploy_deploy_initrd(cluster)
  "#{cfg_kadeploy_deploy_initrd_imgpath(cluster)} "\
  "#{USE_NET_DRIVER ? "ETH_DRV=#{cluster[:drivers][:network]} " : ''}"\
  "ETH_DEV=#{$netiface} "\
  "#{USE_DISK_DRIVER ? "DISK_DRV=#{cluster[:drivers][:disk]} " : ''}"\
  "console=tty#{DEFAULT_CONSOLE_TTY_ID} "\
  "console=ttyS#{DEFAULT_CONSOLE_TTY_ID},#{DEFAULT_CONSOLE_BAUD_RATE}n8 "\
  "ramdisk_size=#{DEFAULT_RAMDISK_SIZE} "\
  "rw noapic init=/linuxrc"
end

CFG_KADEPLOY_SPECIFIC_CONF_FILE_PREFIX = File.join(CFG_KADEPLOY_CONF_PATH,'specific_conf_')
def cfg_kadeploy_specific_conf(cluster)
  postinstallpath = cfg_kadeploy_specific_conf_postinstall_path(cluster)
  "deploy_kernel = #{cfg_kadeploy_deploy_kernel(cluster)}\n"\
  "deploy_initrd = #{cfg_kadeploy_deploy_initrd(cluster)}\n"\
  "block_device = #{cfg_kadeploy_disk_device()}\n"\
  "prod_part = #{CFG_KADEPLOY_PARTITION_PROD_ID}\n"\
  "deploy_part = #{CFG_KADEPLOY_PARTITION_DEPLOY_ID}\n"\
  "tmp_part = #{CFG_KADEPLOY_PARTITION_TMP_ID}\n"\
  "swap_part = #{CFG_KADEPLOY_PARTITION_SWAP_ID}\n"\
  + # Kareboot
  "timeout_reboot_classical = 250\n"\
  "timeout_reboot_kexec = 100\n"\
  "cmd_soft_reboot = ssh -q #{SSH_OPTIONS} -o BatchMode=yes -o ConnectTimeout=2 -o SetupTimeOut=5 -i #{CFG_KADEPLOY_SSHKEY_DEFAULT} root@HOSTNAME_FQDN \"nohup /sbin/reboot -f &>/dev/null &\"\n"\
  "cmd_hard_reboot = #{cfg_kadeploy_reboot_cmd()}\n"\
  + # Kapower
  "cmd_hard_power_on = #{cfg_kadeploy_power_on_cmd()}\n"\
  "cmd_soft_power_off = ssh -q #{SSH_OPTIONS} -o BatchMode=yes -o ConnectTimeout=2 -o SetupTimeOut=5 -i #{CFG_KADEPLOY_SSHKEY_DEFAULT} root@HOSTNAME_FQDN \"nohup /sbin/halt &>/dev/null &\"\n"\
  "cmd_hard_power_off = #{cfg_kadeploy_power_off_cmd()}\n"\
  "cmd_power_status = #{cfg_kadeploy_power_status_cmd()}\n"\
  + # Kaconsole
  "cmd_console = #{cfg_kadeploy_console_cmd()}\n"\
  "kernel_params = console=tty#{DEFAULT_CONSOLE_TTY_ID} console=ttyS#{DEFAULT_CONSOLE_TTY_ID},#{DEFAULT_CONSOLE_BAUD_RATE}n8\n"\
  + # >>> TODO: UPDATE
  "partition_creation_kind = fdisk\n"\
  "pxe_header = #{CFG_PXE_HEADER.gsub("\n",'\n')}\n"\
  + #Automata description
  "macrostep = #{cfg_kadeploy_macrostep(CFG_KADEPLOY_MACROSTEP1)}\n"\
  "macrostep = #{cfg_kadeploy_macrostep(CFG_KADEPLOY_MACROSTEP2)}\n"\
  "macrostep = #{cfg_kadeploy_macrostep(CFG_KADEPLOY_MACROSTEP3)}\n"\
  + (postinstallpath ? "admin_post_install = #{postinstallpath}|tgz|none\n" : '')
  #"nfsroot_kernel = \n"\
  #"nfsroot_params = \n"\
  #cmd_very_hard_power_off = /usr/sbin/pdumix -n HOSTNAME_FQDN -d
  #cmd_soft_power_on = /usr/sbin/pdumix -n HOSTNAME_FQDN -u
end

# kastafior default config
CFG_KASTAFIOR_BIN_FILE = '/usr/bin/kastafior'

# frontend default config
CFG_FRONTEND_USER = 'testuser'
CFG_FRONTEND_USER_PASS = 'pass'
CFG_FRONTEND_SHELL = 'bash'
CFG_FRONTEND_PACKAGES = [
]


# TFTP default config
CFG_TFTP_PATH = '/var/lib/tftpboot'
CFG_TFTP_USER = CFG_KADEPLOY_USER
CFG_TFTP_CONF_FILE = '/etc/default/tftpd-hpa'
CFG_TFTP_PXECONFIG_DIR = 'pxelinux.cfg'
CFG_TFTP_KERNELS_DIR = 'kernels'

def cfg_tftp()
  "# /etc/default/tftpd-hpa\n"\
  "TFTP_USERNAME=\"#{CFG_TFTP_USER}\"\n"\
  "TFTP_DIRECTORY=\"#{CFG_TFTP_PATH}\"\n"\
  "TFTP_ADDRESS=\"0.0.0.0:69\"\n"\
  "TFTP_OPTIONS=\"-v -l -s -c\"\n"
end


# HTTP default config
CFG_HTTP_KERNELS_PATH = 'kernels/'


# Apache2 default config
CFG_APACHE_CONF_FILE = '/etc/apache2/apache2.conf'
CFG_APACHE_SERVER_PATH = '/var/www'
CFG_APACHE_KERNELS_PATH = File.join(CFG_APACHE_SERVER_PATH,CFG_HTTP_KERNELS_PATH)

def cfg_apache()
  ''
end


# PXE default config
CFG_PXE_DISK='hd0'
CFG_PXE_PART=3
CFG_PXE_KERNEL='chain.c32'
CFG_PXE_BOOTFILES = [
  'chain.c32',
  'mboot.c32',
  'pxelinux.0',
  'gpxelinux.0',
]
CFG_PXE_CONFIG_PATH = File.join(CFG_TFTP_PATH,CFG_TFTP_PXECONFIG_DIR)
CFG_PXE_KERNELS_PATH = File.join(CFG_TFTP_PATH,CFG_TFTP_KERNELS_DIR)
CFG_PXE_HEADER = \
  "PROMPT 1\n"\
  "SERIAL 0 #{DEFAULT_CONSOLE_BAUD_RATE}\n"\
  "DEFAULT bootlabel\n"\
  "DISPLAY messages\n"\
  "TIMEOUT 50\n\n"\
  "label bootlabel\n"

def cfg_pxe(bootkernel=CFG_PXE_KERNEL,bootdisk=CFG_PXE_DISK,bootpart=CFG_PXE_PART)
  CFG_PXE_HEADER +
  "KERNEL #{bootkernel}\n"\
  "APPEND #{bootdisk} #{bootpart}\n"
end


# DNS default config
def cfg_dns_masknb()
  4 - (IPAddr.new($network[:mask]).to_i.to_s(2).count('1') / 8)
end

def cfg_dns_master_node(node)
  nodecfg = "#{node[:name]}      IN    A    #{node[:ipv4]}\n"
  nodecfg += "#{node[:name]}.#{node[:cluster][:name]}      IN    A    #{node[:ipv4]}\n" if node[:type] == :NODE
  nodecfg
end

def cfg_dns_reverse_node(node)
  ip = node[:ipv4].split('.')[-cfg_dns_masknb()..-1].reverse.join('.')
  "#{ip}    IN    PTR    #{node[:fqdn]}.\n"
end

def cfg_dns_base()
  "$TTL 3h\n"\
  "@    IN    SOA    #{$kanodes[:dns][:fqdn]}. postmaster.#{$kanodes[:dns][:fqdn]}. (\n"\
  "  #{Time.now.strftime("%Y%m%d%H%M%S")}\n"\
  "  4h\n"\
  "  1h\n"\
  "  4w\n"\
  "  1h\n"\
  ")\n"
end

def cfg_dns_master()
  nodescfg = ''
  $kanodes.each do |n,h|
    nodescfg += "#{cfg_dns_master_node(h)}\n"
  end

  "#{cfg_dns_base()}\n"\
  "@         IN    NS    #{$kanodes[:dns][:fqdn]}.\n"\
  "@         IN    A     #{$kanodes[:kadeploy][:ipv4]}\n"\
  + nodescfg
end

def cfg_dns_reverse()
  nodescfg = ''
  excls = []
  nodescfg += "#{cfg_dns_reverse_node($kanodes[:kadeploy])}\n"
  excls << $kanodes[:kadeploy][:ipv4]
  $kanodes.each do |n,h|
    unless excls.include?(h[:ipv4])
      nodescfg += "#{cfg_dns_reverse_node(h)}\n"
      excls << h[:ipv4]
    end
  end

  "#{cfg_dns_base()}\n"\
  "@         IN    NS    #{$kanodes[:dns][:fqdn]}.\n"\
  + nodescfg
end


# Bind9 default config
CFG_BIND_PATH='/etc/bind'
CFG_BIND_NAMED_FILE = File.join(CFG_BIND_PATH,'named.conf')
CFG_BIND_CONFIG_FILE_PREFIX = File.join(CFG_BIND_PATH,'db.')

def cfg_bind_reverse_domain()
 $network[:ipv4].to_s.split('.')[0..(4-cfg_dns_masknb()-1)].reverse.join('.')
end

def cfg_bind_reverse_file()
  "#{CFG_BIND_CONFIG_FILE_PREFIX}#{cfg_bind_reverse_domain()}"
end

def cfg_bind_master_file()
  "#{CFG_BIND_CONFIG_FILE_PREFIX}#{DOMAIN}"
end

def cfg_bind(dnsfwd)
  "zone \"#{DOMAIN}\" {\n"\
  "  type master;\n"\
  "  file \"#{cfg_bind_master_file()}\";\n"\
  "};\n\n"\
  "zone \"#{cfg_bind_reverse_domain()}.in-addr.arpa\" {\n"\
  "  type master;\n"\
  "  file \"#{cfg_bind_reverse_file()}\";\n"\
  "};\n"\
  "#{(dnsfwd.empty? ? '' : \
    "options {\n"\
    "  forwarders {\n"\
    "    #{dnsfwd};\n"\
    "  };\n"\
    "};\n"\
  )}"
end


# Resolv.conf default config
CFG_RESOLVCONF_FILE = '/etc/resolv.conf'

def cfg_resolvconf()
  "domain #{DOMAIN}\n"\
  "search #{DOMAIN}\n"\
  "nameserver #{$kanodes[:dns][:ipv4]}\n"
end


# DHCP default config
CFG_DHCP_CONF_FILE='/etc/dhcp/dhcpd.conf'
CFG_DHCP_PXE_MAGIC='F1:00:74:7E'
CFG_DHCP_PXECLIENT='gpxelinux.0'

def cfg_dhcp_node(node)
  "  host #{node[:fqdn]} {\n"\
  "    hardware ethernet #{node[:mac]};\n"\
  "    fixed-address #{node[:ipv4]};\n"\
  "    option host-name \"#{node[:name]}\";\n"\
  "  }\n"
end

def cfg_dhcp()
  nodescfg = ''
  excls = []
  nodescfg += "#{cfg_dhcp_node($kanodes[:kadeploy])}\n"
  excls << $kanodes[:kadeploy][:ipv4]
  $kanodes.each do |n,h|
    unless excls.include?(h[:ipv4])
      nodescfg += "#{cfg_dhcp_node(h)}\n"
      excls << h[:ipv4]
    end
  end

  "default-lease-time 28800;\n"\
  "max-lease-time	86400;\n"\
  + # specific boot options
  "allow booting;\n"\
  "allow bootp;\n\n"\
  "not-authoritative;\n\n"\
  "use-host-decl-names on;\n\n"\
  "log-facility local7;\n\n"\
  + # PXE class options
  "option space PXE;\n"\
  "option PXE.mtftp-ip code 1 = ip-address;\n"\
  "option PXE.mtftp-cport code 2 = unsigned integer 16;\n"\
  "option PXE.mtftp-sport code 3 = unsigned integer 16;\n"\
  "option PXE.mtftp-tmout code 4 = unsigned integer 8;\n"\
  "option PXE.mtftp-delay code 5 = unsigned integer 8;\n"\
  "option PXE.discovery-control code 6 = unsigned integer 8;\n"\
  "option PXE.discovery-mcast-addr code 7 = ip-address;\n\n"\
  + # pxelinux options
  "option space pxelinux;\n"\
  "option pxelinux.magic code 208 = string;\n"\
  "option pxelinux.configfile code 209 = text;\n"\
  "option pxelinux.pathprefix code 210 = text;\n"\
  "option pxelinux.reboottime code 211 = unsigned integer 32;\n"\
  "site-option-space \"pxelinux\";\n"\
  "option pxelinux.magic #{CFG_DHCP_PXE_MAGIC};\n"\
  "option pxelinux.reboottime 30;\n\n"\
=begin
  # PXE class
  "class \"PXE\" {\n"\
	  "match if substring(option vendor-class-identifier, 0, 9) = \"PXEClient\";\n"\
=end
  "  filename \"#{CFG_DHCP_PXECLIENT}\";\n"\
  "  option vendor-class-identifier \"PXEClient\";\n"\
  "  vendor-option-space PXE;\n"\
	"  option PXE.mtftp-ip 0.0.0.0;\n"\
=begin
  "}\n\n"\

  + # Experiments network
=end
  "subnet #{$network[:ipv4]} netmask #{$network[:mask]} {\n"\
  "  option subnet-mask #{$network[:mask]};\n"\
  "  option broadcast-address #{$network[:broadcast]};\n"\
  "  option routers #{$network[:gateway]};\n"\
  "  option domain-name \"#{DOMAIN}\";\n"\
  "  option domain-name-servers #{$kanodes[:dns][:ipv4]};\n"\
  + # Kadeploy server
  "  next-server #{$kanodes[:tftp][:ipv4]};\n\n"\
  + # Deploiement nodes
  ""\
  + nodescfg +
  "}\n"
end



# SQL default config
CFG_SQL_USER = CFG_KADEPLOY_USER
CFG_SQL_DB = 'deploy3'
CFG_SQL_PASS_ROOT = 'kadeploy'
CFG_SQL_PASS_USER = "#{CFG_KADEPLOY_USER}-pass"

def cfg_sql()
  # Cleaning up
  "DROP DATABASE IF EXISTS #{CFG_SQL_DB};\n"\
  + # Kadeploy database
  "CREATE DATABASE #{CFG_SQL_DB};\n"\
  + # Kadeploy user
  "GRANT ALL ON #{CFG_SQL_DB}.* TO '#{CFG_SQL_USER}'@'#{$kanodes[:kadeploy][:fqdn]}' IDENTIFIED BY '#{CFG_SQL_PASS_USER}';\n"\
  + # Kadeploy tables, table environments
  "CREATE TABLE IF NOT EXISTS #{CFG_SQL_DB}.`environments` (\n"\
  "  `id` int(10) unsigned NOT NULL auto_increment,\n"\
  "  `name` varchar(255) NOT NULL default '',\n"\
  "  `version` int(10) unsigned NOT NULL default '0',\n"\
  "  `description` text,\n"\
  "  `author` varchar(56) NOT NULL default '',\n"\
  "  `tarball` varchar(512) NOT NULL,\n"\
  "  `preinstall` varchar(512) NOT NULL,\n"\
  "  `postinstall` varchar(512) NOT NULL,\n"\
  "  `hypervisor` varchar(255) NOT NULL,\n"\
  "  `hypervisor_params` varchar(255) NOT NULL,\n"\
  "  `initrd` varchar(255) NOT NULL,\n"\
  "  `kernel` varchar(255) NOT NULL,\n"\
  "  `kernel_params` varchar(255) NOT NULL,\n"\
  "  `fdisk_type` varchar(2) default NULL,\n"\
  "  `filesystem` varchar(9) default NULL,\n"\
  "  `user` varchar(255) default 'nobody',\n"\
  "  `allowed_users` varchar(512) NOT NULL,\n"\
  "  `environment_kind` varchar(10) NOT NULL,\n"\
  "  `visibility` varchar(8) NOT NULL,\n"\
  "  `demolishing_env` int(8) NOT NULL default '0',\n"\
  "  PRIMARY KEY  (`id`)\n"\
  ") ENGINE=MyISAM  DEFAULT CHARSET=utf8;\n"\
  + # table log
  "CREATE TABLE IF NOT EXISTS #{CFG_SQL_DB}.`log` (\n"\
  "  `deploy_id` varchar(41) NOT NULL,\n"\
  "  `hostname` varchar(256) NOT NULL,\n"\
  "  `step1` varchar(45) NOT NULL,\n"\
  "  `step2` varchar(45) NOT NULL,\n"\
  "  `step3` varchar(45) NOT NULL,\n"\
  "  `timeout_step1` smallint(5) unsigned NOT NULL,\n"\
  "  `timeout_step2` smallint(5) unsigned NOT NULL,\n"\
  "  `timeout_step3` smallint(5) unsigned NOT NULL,\n"\
  "  `retry_step1` tinyint(1) unsigned NOT NULL,\n"\
  "  `retry_step2` tinyint(1) unsigned NOT NULL,\n"\
  "  `retry_step3` tinyint(1) unsigned NOT NULL,\n"\
  "  `start` int(10) unsigned NOT NULL,\n"\
  "  `step1_duration` int(10) unsigned NOT NULL,\n"\
  "  `step2_duration` int(10) unsigned NOT NULL,\n"\
  "  `step3_duration` int(10) unsigned NOT NULL,\n"\
  "  `env` varchar(64) NOT NULL,\n"\
  "  `anonymous_env` varchar(6) NOT NULL,\n"\
  "  `md5` varchar(35) NOT NULL,\n"\
  "  `success` varchar(6) NOT NULL,\n"\
  "  `error` varchar(255) NOT NULL,\n"\
  "  `user` varchar(16) NOT NULL\n"\
  ") ENGINE=MyISAM DEFAULT CHARSET=utf8;\n"\
  + # table nodes
  "CREATE TABLE IF NOT EXISTS #{CFG_SQL_DB}.`nodes` (\n"\
  "  `hostname` varchar(256) NOT NULL,\n"\
  "  `state` varchar(16) NOT NULL,\n"\
  "  `env_id` int(10) NOT NULL,\n"\
  "  `date` int(10) unsigned NOT NULL,\n"\
  "  `user` varchar(16) NOT NULL\n"\
  ") ENGINE=MyISAM DEFAULT CHARSET=utf8;\n"\
  + # rights
  "CREATE TABLE IF NOT EXISTS #{CFG_SQL_DB}.`rights` (\n"\
  "  `user` varchar(30) NOT NULL,\n"\
  "  `node` varchar(256) NOT NULL,\n"\
  "  `part` varchar(50) NOT NULL\n"\
  ") ENGINE=MyISAM DEFAULT CHARSET=utf8;\n"\
  + # Kadeploy rights
  "INSERT INTO #{CFG_SQL_DB}.rights (user,node,part) VALUES('root','*','*');\n"\
  "FLUSH PRIVILEGES;\n"
end


# mySQL default config
CFG_MYSQL_CONF_FILE = '/etc/mysql/my.cnf'
CFG_MYSQL_VERSION = '5.1'
CFG_MYSQL_PORT = 3306

def cfg_mysql()
  "[client]\n"\
  "port = #{CFG_MYSQL_PORT}\n"\
  "\n"\
  "socket = /var/run/mysqld/mysqld.sock\n"\
  "[mysqld_safe]\n"\
  "socket = /var/run/mysqld/mysqld.sock\n"\
  "nice = 0\n"\
  "\n"\
  "[mysqld]\n"\
  "user = mysql\n"\
  "pid-file = /var/run/mysqld/mysqld.pid\n"\
  "socket = /var/run/mysqld/mysqld.sock\n"\
  "port = #{CFG_MYSQL_PORT}\n"\
  "basedir = /usr\n"\
  "datadir = /var/lib/mysql\n"\
  "tmpdir = /tmp\n"\
  "language = /usr/share/mysql/english\n"\
  "skip-external-locking\n"\
  "query_cache_limit = 1M\n"\
  "query_cache_size = 16M\n"\
  "expire_logs_days = 10\n"\
  "max_binlog_size = 100M\n"\
  "\n"\
  "[mysqldump]\n"\
  "quick\n"\
  "quote-names\n"\
  "max_allowed_packet = 16M\n"\
  "\n"\
  "[mysql]\n"\
  "no-auto-rehash\n"\
  "\n"\
  "[isamchk]\n"\
  "key_buffer = 16M\n"
end

# Debian networking system

CFG_NETWORKING_CONF_FILE = '/etc/network/interfaces'

def cfg_networking_bridge(ifname,macaddr)
  "auto lo\n"\
  "iface lo inet loopback\n\n"\
  "iface #{ifname} inet manual\n\n"\
  "auto #{KVM_BRIDGE_DEV}\n"\
  "iface #{KVM_BRIDGE_DEV} inet dhcp\n"\
  "  bridge_ports #{ifname}\n"\
  "bridge_hw #{macaddr}\n"
end




if g5k?
  $site = `hostname --fqdn`.chomp.split('.',2)[1]
else
  $site = nil
end
$srchost = `hostname --fqdn`.strip


$mode = :KAVLAN
$allnodes=[]
$kanodes={}
$kaenvs={}
$clusters={}
$deplkernels = {}
$stunnels = {}
$hostscache = {}
$network = {}
$deploysendmeth = :HTTP

options = {}

MSG_ERROR=0
MSG_WARNING=1
MSG_INFO=2

def msg(str, type=nil, quit=false)
  case type
  when MSG_ERROR
    puts("### Error: #{str} ###")
  when MSG_WARNING
    puts("### Warning: #{str} ###")
  when MSG_INFO
    puts("[#{(Time.now - $startt).to_i}] #{str}")
  else
    puts str
  end
  exit 1 if quit
end

def kavlan_gw()
  "kavlan-#{$kavlan_id}#{$site.empty? ? '' : ".#{$site}"}"
end

def kavlan_node(name)
  "#{name.split('.')[0].split("-#{kavlan_gw()}")[0]}-#{kavlan_gw()}"
end

def kvm_gw()
	$network[:gateway] || KVM_GATEWAY
end

def getgw()
	ret = nil
	case $mode
		when :KAVLAN, :VLANKVM
			ret = kavlan_gw()
		when :KVM
			ret = kvm_gw()
		else
			msg('Unknown mode',MSG_ERROR,true)
	end
	ret
end

def getnode(name)
	ret = nil
	case $mode
		when :KAVLAN, :VLANKVM
			ret = kavlan_node(name)
		when :KVM
			ret = name
		else
			msg('Unknown mode',MSG_ERROR,true)
	end
	ret
end

def gethostbysession(session,address = false)
  unless $hostscache[session]
    $hostscache[session] = {}
		$hostscache[session][:name] =
			sexec(session,'hostname',true,true,false,false)[0].chomp
		$hostscache[session][:address] =
			sexec(session,'hostname -i',true,true,false,false)[0].chomp
  end
	if address
		$hostscache[session][:address]
	else
		$hostscache[session][:name]
	end
end

def sexec(session, cmd, critical = true, showerr = true, showout = false, checkhost = true)
  outs = []
  errs = []
  if checkhost
    host = gethostbysession(session)
  else
    host = session.host
  end

  chtmp = session.open_channel do |channel|
    channel.exec(cmd) do |ch, success|
      unless success
        msg("unable to execute '#{cmd}' on #{host}",MSG_ERROR)
      end
      msg("Executing '#{cmd}' on #{host}]",MSG_INFO) \
        if $debug

      channel.on_data do |ch,data|
        outs += data.strip.split("\n").collect!{|l| l.strip}
        msg("(#{host}) #{data.strip}") \
          if $debug or showout
      end

      channel.on_extended_data do |ch,type,data|
        errs += data.strip.split("\n").collect!{|l| l.strip}
      end

      channel.on_request("exit-status") do |ch, data|
        status = data.read_long
        if status != 0 and showerr
          msg("exec of '#{cmd}' on #{host} failed " \
            "with return status #{status.to_s}",MSG_ERROR)
          msg("---stdout dump---")
          outs.each { |out| msg(out) } unless outs.empty?
          msg("---stderr dump---")
          errs.each { |err| msg(err) } unless errs.empty?
          msg("---\n")
          exit 1 if critical
        end
      end

      #channel.wait
    end
  end

  chtmp.wait

  outs
end

SSH_TUNNEL_TIMEOUT=20
def ssh_tunnel_create(session,dstport,dsthost,srcport=nil,srchost=nil)
  srcport = dstport unless srcport
  srchost = gethostbysession(session,true) unless srchost

  unless $stunnels["#{srchost}:#{srcport}"]
    # Copying ssh private key on gateway
    scp(srchost,$sshkeyfile,'.ssh/')
    # Kill already existing process listening on srcport
    tmp = sexec(session,"lsof -i4 -n | grep LISTEN | grep 127.0.0.1:#{srcport}",false,false)[0]
    if tmp and !tmp.empty?
      msg("A process is already listening on port #{srcport}, trying to kill it",MSG_WARNING)
      sexec(session,"kill #{tmp.chomp.split[1]}")
      time_start = Time.now
      begin
        tmp = sexec(session,"lsof -i4 -n | grep LISTEN | grep 127.0.0.1:#{srcport}",false,false)[0]
        sexec(session,"kill -9 #{tmp.chomp.split[1]}") if (Time.now - time_start) > SSH_TUNNEL_TIMEOUT
        msg("Killing process that listen on #{srchost}:#{srcport} failed",MSG_ERROR,true) if Time.now - time_start > SSH_TUNNEL_TIMEOUT
        sleep(0.1)
      end until !tmp or tmp.empty?
    end

    $stunnels["#{srchost}:#{srcport}"] = {}
    $stunnels["#{srchost}:#{srcport}"][:dsthost] = dsthost
    $stunnels["#{srchost}:#{srcport}"][:dstport] = dstport
    #$stunnels["#{srchost}:#{srcport}"][:thread] = Thread.new do 

#gwsession = Net::SSH::Gateway.new(kavlan_gw(), ENV['USER'], :keys => $sshkeyfile)
#gwsession.ssh(kavlan_node($kaserver),'root') do |mysession|
      sexec(session,"ssh #{SSH_OPTIONS} -N -L #{srcport}:#{dsthost}:#{dstport} #{ENV['USER']}@#{getgw()} -i #{File.join('.ssh',File.basename($sshkeyfile))} &>/dev/null &")
#end
#    end
#    $stunnels["#{srchost}:#{srcport}"][:thread].run
    time_start = Time.now
    begin
      tmp = sexec(session,"lsof -i4 -n | grep LISTEN | grep 127.0.0.1:#{srcport}",false,false)[0]
      sleep(0.1)
      msg("SSH tunnel creation on #{srchost}:#{srcport} failed",MSG_ERROR,true) if Time.now - time_start > SSH_TUNNEL_TIMEOUT
    end while !tmp or tmp.empty?
    $stunnels["#{srchost}:#{srcport}"][:pid] = tmp.split[1]
  else
    if $stunnels["#{srchost}:#{srcport}"][:dsthost] != dsthost \
      or $stunnels["#{srchost}:#{srcport}"][:dstport] != dstport
      msg("Trying to create two tunnels on the same local port (#{srcport})",MSG_WARNING)
    end
  end
end
=begin
      chtmp = session.open_channel do |channel|
        channel.exec("ssh -o StrictHostKeyChecking=no -N -L #{srcport}:#{dsthost}:#{dstport} #{ENV['USER']}@#{kavlan_gw()}") do |ch,success|
        end
      end
      $stunnels["#{srchost}:#{srcport}"][:channel] = chtmp
      chtmp.wait
=end

def ssh_tunnel_destroy(session,srcport,srchost)
  if $stunnels["#{srchost}:#{srcport}"]
    # Removing ssh private key
    sexec(session,"rm -f #{File.join('.ssh',File.basename($sshkeyfile))}")
    if $stunnels["#{srchost}:#{srcport}"][:pid]
      tmp = sexec(session,"ps -p #{$stunnels["#{srchost}:#{srcport}"][:pid]}",false,false)
      if tmp and tmp[1] and !tmp[1].chomp.empty?
        sexec(session,"kill #{$stunnels["#{srchost}:#{srcport}"][:pid]}")
      end
    end
#    $stunnels["#{srchost}:#{srcport}"][:thread].kill
#    $stunnels["#{srchost}:#{srcport}"][:thread].join
    $stunnels.delete("#{srchost}:#{srcport}")
  end
end

=begin
def ssh_tunnels_destroy()
  $stunnels.values.each do |tunnel|
    #tunnel[:channel].close if tunnel[:channel]
    if tunnel[:thread]
      tunnel[:thread].kill
      tunnel[:thread].join
    end
  end
end
=end

def apt_cmd(session,shcmd,aptcmd,aptopts,params='')
	aptproxy = nil
	case $mode
		when :KAVLAN, :VLANKVM
			aptproxy = 'Acquire::http::Proxy=\"http://localhost:3128\"'
		when :KVM
			aptproxy = ''
		else
			msg('Unknown mode',MSG_ERROR,true)
	end

  optname = Proc.new { |v|
      if v.size > 1
        "--#{v}"
      else
        "-#{v}"
      end
  }

  if aptopts.is_a?(Hash)
    aptopts['o'] = [aptproxy] if aptproxy and !aptproxy.empty?
    tmpopts = []
    aptopts.each do |k,v|

      if v.is_a?(String)
        tmpopts << "#{optname.call(k)} #{v}"
      elsif v.is_a?(Array)
        v.each { |o| tmpopts << "#{optname.call(k)} #{o}" }
      elsif v == nil
        tmpopts << k
      end
    end
    aptopts = tmpopts.join(' ')
  elsif aptopts.is_a?(Array)
    aptopts = aptopts.collect{|v| optname.call(v)}.join(' ')
    aptopts += " #{optname.call('o')} #{aptproxy}" if aptproxy and !aptproxy.empty?
  end
  params = params.join(' ') if params.is_a?(Array)

  sexec(session,"#{shcmd} #{aptcmd} #{aptopts} #{params}")
end

def apt_update(session)
  apt_cmd(session,'apt-get','update',['q'])
end

def apt_install(session,packages)
  apt_cmd(session,'apt-get','install',['q','y','force-yes','allow-unauthenticated'],packages)
end

def apt_remove(session,packages)
  apt_cmd(session,'apt-get','remove',['q','y','force-yes','purge'],packages)
end

def get_open_port()
  tmp=`netstat -l -n`
  usedports=[]
  tmp.each do |line|
    if line =~ /^\w+\s+\d+\s+\d+\s+.+:([-_\.\w]+)\s+.+:.+\s+\w*$/
      usedports << Regexp.last_match(1) unless usedports.include?(Regexp.last_match(1))
    end
  end

  begin
    randport = rand(2**16-2**10-1) + 2**10
  end while usedports.include?(randport)
  randport
end

def scp(dsthost,srcfile,dstfile)
	case $mode
		when :KAVLAN, :VLANKVM
			randport=get_open_port()
			cmd="ssh #{SSH_OPTIONS} -N -L #{randport}:#{dsthost}:22 -i #{$sshkeyfile} #{ENV['USER']}@#{getgw()} &>/dev/null & echo $!"
			msg(cmd) if $debug
			pid=`#{cmd}`
			#pid=`ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -N -L #{randport}:#{dsthost}:22 #{ENV['USER']}@#{getgw()} &>/dev/null & echo $!`

			time_start = Time.now
			begin
				tmp = `lsof -i4 -n | grep LISTEN | grep 127.0.0.1:#{randport}`
				sleep(0.1)
				msg("SSH tunnel creation on localhost:#{randport} failed",MSG_ERROR,true) \
					if Time.now - time_start > 4
			end while !tmp or tmp.empty?

			cmd="scp -P #{randport} -r #{SSH_OPTIONS} -i #{$sshkeyfile} #{srcfile} root@localhost:#{dstfile} 2>&1 | grep -v 'Warning: Permanently added'"
			msg(cmd) if $debug
			`#{cmd}`
			`kill #{pid}`

		when :KVM
			cmd="scp -r -i #{$sshkeyfile} #{SSH_OPTIONS} #{srcfile} root@#{dsthost}:#{dstfile} 2>&1 | grep -v 'Warning: Permanently added'"
			msg(cmd) if $debug
			`#{cmd}`
		else
	end
end

def kadeploy_update(session,mountpath)
  # Check if debian package is installed
  tmp = sexec(session,'dpkg -s kadeploy-common')
  msg('dpkg error',MSG_ERROR,true) if !tmp or tmp.empty?
	tmp.each do |line|
		if line =~ /^Status: .* ([^ ]+)$/
			unless Regexp.last_match(1) == 'installed'
				msg("debian package 'kadeploy-common' is not installed",MSG_ERROR,true)
			end
		end
	end

  $update_paths.each do |key,localpath|
		next if key == UPDATE_DIR_VAR
		rlocalpath = File.join(mountpath,localpath)
    msg("Updating '#{key}' files",MSG_INFO)
    remotepaths = sexec(session,"dpkg -L kadeploy-common | grep '#{UPDATE_PATH_CHECK[key]}$'")
		remotepaths = [remotepaths] if remotepaths.is_a?(String)
    msg("file '#{UPDATE_PATH_CHECK[key]}' not found in kadeploy-common package",MSG_ERROR,true) if !tmp or tmp.empty?
		remotepaths.each do |remotepath|
			remotepath=remotepath.split(UPDATE_PATH_CHECK[key])[0]
			# Check nfs paths
			tmpcheck = sexec(session,"ls -a #{rlocalpath}",nil,false,false)
			msg("file '#{rlocalpath}' not found",MSG_ERROR,true) if !tmpcheck or tmpcheck.empty?

			localentries = Dir.entries(File.join($update_paths[UPDATE_DIR_VAR],localpath))
			localentries.delete('.')
			localentries.delete('..')
			localentries.each do |localentry|
				unless $update_paths.values.include?(File.join(localpath,localentry))
					sexec(session,"rm -Rf #{File.join(remotepath,localentry)}",nil,true)
					sexec(session,"ln -s #{File.join(rlocalpath,localentry)} #{remotepath}",nil,true)
					sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{File.join(remotepath,localentry)}")
				end
      end
    end
  end
end

def tempfile(content)
  tmp = Tempfile.new(__FILE__)
  tmp.write(content)
  tmp.close

  yield(tmp.path)

  tmp.unlink
end

def http_tunnel(host,session, verbose=true)
  host = host[:basename] if host.is_a?(Hash)
	case $mode
		when :KAVLAN, :VLANKVM
			msg('Creating HTTP proxy SSH tunnel',MSG_INFO) if verbose
			ssh_tunnel_create(session,HTTP_PROXY_PORT,HTTP_PROXY_ADDR)

			yield

			msg('Destroying HTTP proxy SSH tunnel',MSG_INFO) if verbose
			ssh_tunnel_destroy(session,3128,getnode(host))
		when :KVM
			msg('Creating HTTP proxy SSH tunnel',MSG_INFO) if verbose
			tmp = sexec(session,'route -n')
			msg('can\'t get route informations',MSG_ERRO,true) if !tmp or tmp.empty?
			gateway = nil
			iface = nil
			routed=false
			tmp.each do |line|
				if line =~ /^(\S+)\s+0\.0\.0\.0\s+\S+\s+.+$/
					routed = true if $network[:ipaddr].include?(Regexp.last_match(1))
				elsif line =~ /^0\.0\.0\.0\s+(\S+)\s+.+\s+(\S+)\s*$/
					gateway = Regexp.last_match(1)
					iface = Regexp.last_match(2)
					break
				end
			end
			sexec(session,"route add -host #{$network[:gateway]} dev #{$netiface}") unless routed
			sexec(session,'route del default') if gateway
			sexec(session,"route add default gw #{$network[:gateway]}")

			yield

			msg('Destroying HTTP proxy SSH tunnel',MSG_INFO) if verbose
			sexec(session,'route del default')
			sexec(session,"route add default gw #{gateway} dev #{iface}") if gateway
		else
			msg('Unknown mode',MSG_ERROR,true)
	end
end

def set_default_route(session)
	if $mode == :KVM
		tmp = sexec(session,'route -n')
		msg('can\'t get route informations',MSG_ERRO,true) if !tmp or tmp.empty?
		gateway = false
		routed = false
		tmp.each do |line|
			if line =~ /^\S+\s+0\.0\.0\.0\s+\S+\s+.+$/
				routed = true
			elsif line =~ /^0\.0\.0\.0\s+\S+\s+.+\s+\S+\s*$/
				gateway = true
			end
		end
		sexec(session,"route add -host #{KVM_GATEWAY} dev #{$netiface}") unless routed
		sexec(session,"route add default gw #{KVM_GATEWAY} dev #{$netiface}") unless gateway
	end
end

def kadeploy_tunnel(host,session)
	case $mode
		when :KAVLAN, :VLANKVM
			msg('Creating tunnel to kadeploy repository',MSG_INFO)
			sexec(session,"sed -i -e '/^.*#{DEB_REPOSITORY.gsub('/','\/')}.*$/d' /etc/apt/sources.list")
			sexec(session,"echo 'deb #{DEB_REPOSITORY} / ' >> /etc/apt/sources.list")

			http_tunnel(host,session) do
				yield
			end
			msg('Destroying tunnel to kadeploy repository',MSG_INFO)
		when :KVM
			msg('Creating tunnel to kadeploy repository',MSG_INFO)
			randport=get_open_port()
  		uri = URI.parse(URI.decode(DEB_REPOSITORY))
			url = "#{uri.scheme}://#{getgw()}:#{randport}#{uri.path}"
			sexec(session,"sed -i -e '/^.*#{getgw()}.*$/d' /etc/apt/sources.list")
			sexec(session,"echo 'deb #{url} / ' >> /etc/apt/sources.list")

			cmd="ssh #{SSH_OPTIONS} -N -L #{getgw()}:#{randport}:#{uri.host}:80 -i #{$sshkeyfile} #{KVM_G5K_USER}@#{KVM_G5K_SITE} 1>/dev/null 2>/dev/null & echo $!"
			msg(cmd) if $debug
			pid=`#{cmd}`

			time_start = Time.now
			begin
				tmp = `lsof -i4 -n | grep LISTEN | grep #{getgw()}:#{randport}`
				sleep(0.1)
				msg("SSH tunnel creation on localhost:#{randport} failed",MSG_ERROR,true) \
					if Time.now - time_start > 4
			end while !tmp or tmp.empty?

			http_tunnel(host,session) do
				yield
			end

			msg('Destroying tunnel to kadeploy repository',MSG_INFO)
			`kill #{pid}`
		else
			msg('Unknown mode',MSG_ERROR,true)
	end
end

def select_type(hash,type)
  hash.select { |n,h| h[:type] == type }.collect { |v| v[1] }
end

options[:node_list]   = nil
options[:host_list]   = nil
options[:debpackages] = []
options[:gempackages] = []
options[:git]         = nil
options[:ssh_key]     = nil
options[:kastafior]     = nil
options[:version]     = nil
options[:daemon_kadeploy] = nil
options[:update_file] = nil
$debug				        = false
$netiface 						= NET_ADMIN_IFACE

args = ARGV.dup

optparse = OptionParser.new(USAGE) do |opts|
	opts.on( '-h', '--help', 'Display this screen' ) do
  		puts opts
  		exit
	end

	opts.on( '-f', '--deploy-node-list <nodelist_file>', 'Specify a file containing the list of the nodes that should be deployed' ) do |n|
  	options[:node_list] = n
	end

	opts.on( '-F', '--hosts-node-list <nodelist_file>', 'Specify a file containing the list of the hosting nodes (VLAN hostnames) to be used when using the VLAN-KVM mode (see --vlan-kvm)' ) do |n|
  	options[:host_list] = n
	end

	opts.on( '-k', '--kastafior <kastafior_file>', 'Use a specific version of kastafior' ) do |k|
  	options[:kastafior] = k
	end

	opts.on( '-i', '--ssh-key [<ssh_key_file>]', 'Specify the path of the ssh private key to use' ) do |k|
  	options[:ssh_key] = k
	end

	opts.on( '-K', '--kvm', 'Use KVM nodes instead of deployed ones in kavlan (default)' ) do |k|
		$mode = :KVM
	end

	opts.on( '-V', '--vlan-kvm', 'Use KVM nodes in a kavlan' ) do |k|
		$mode = :VLANKVM
	end

	opts.on( '-g', '--git [<git_hash|git_tag>]', "Specify a specific version to install from git repository (if not specified, taking the last revision). Some packages are installed on one of the nodes in order to build the debian package (See `apt-get build-dep kadeploy-server` + deb: #{})" ) do |n|
  	options[:git] = n || :git_last
	end

	opts.on( '-u', '--update <updatefile>', "Update kadeploy files (the YAML update file should contain the local path for keys {#{UPDATE_PATH_CHECK.keys * ','}} to be bind on kadeploy server)" ) do |u|
  	options[:update_file] = u
	end

	opts.on( '-p', '--debpackages <package1>,<package2>,<...>', Array, 'Specify additional debian packages to be installed on the frontend' ) do |p|
  	options[:debpackages] = p
	end

	opts.on( '-i', '--net-iface <name>', "Specify the default network interfaces to be used on nodes (default: #{NET_ADMIN_IFACE})" ) do |i|
  	$netiface = i
	end

	opts.on( '-T', '--use-tftp', "Use TFTP protocol to send the minimal deployment image (default: HTTP)" ) do
    $deploysendmeth = :TFTP
	end

	opts.on( '-d', '--kadeploy-daemon <node_address>', 'Specify which node should be used as kadeploy daemon (default: first node)' ) do |d|
  	options[:daemon_kadeploy] = d || nil
	end

	opts.on( '', '--debug', 'Verbose display of every instruction sent' ) do
  	$debug = true
	end
end

$startt = Time::now

begin
  optparse.parse!
rescue OptionParser::InvalidOption => e
  msg(e.to_s,MSG_ERROR,true)
end

if ARGV.size < 2
  msg(USAGE)
  exit 1
end

if options[:kastafior] and !File.exists?(options[:kastafior])
  msg("kastafior file #{options[:kastafior]} not found",MSG_ERROR,true)
else
  options[:kastafior] = File.expand_path(options[:kastafior])
end

if options[:ssh_key]
  if File.exists?(options[:ssh_key])
    $sshkeyfile = options[:ssh_key]
  else
    msg("ssh key #{options[:ssh_key]} not found",MSG_ERROR,true)
  end
else
  sshkeyfiles = SSH_KEYS.select { |keypath| File.exists?(keypath) }
  if sshkeyfiles.empty?
    msg("no ssh private key file found (specify one with -k)",MSG_ERROR,true)
  else
    $sshkeyfile = sshkeyfiles[0]
  end
end

$update_paths = {}
if options[:update_file]
  if File.exist?(options[:update_file])
    begin
      $update_paths = YAML.load_file(options[:update_file])
    rescue ArgumentError
      msg("Invalid YAML file '#{options[:update_file]}'",MSG_ERROR,true)
    end
    msg("Invalid YAML file '#{options[:update_file]}'",MSG_ERROR,true) \
      unless $update_paths

		$update_paths[UPDATE_DIR_VAR] = '.' unless $update_paths[UPDATE_DIR_VAR]

		$update_paths[UPDATE_DIR_VAR] = File.expand_path($update_paths[UPDATE_DIR_VAR])

    begin
    	msg("#{options[:update_file]}: invalid working directory '#{$update_paths[UPDATE_DIR_VAR]}'",MSG_ERROR,true) unless File.directory?($update_paths[UPDATE_DIR_VAR])
    rescue ArgumentError
    	msg("#{options[:update_file]}: invalid working directory '#{$update_paths[UPDATE_DIR_VAR]}'",MSG_ERROR,true)
		end

    nb = 0
		updatepath = $update_paths[UPDATE_DIR_VAR]
    $update_paths.each do |key,path|
			$update_paths[key] = path
			#$update_paths[key] = File.expand_path(path)
			next if key == UPDATE_DIR_VAR
      begin
        msg("#{options[:update_file]}: file not found '#{path}'",MSG_ERROR,true) \
          unless File.exist?(File.join(updatepath,$update_paths[key]))

        if UPDATE_PATH_CHECK[key]
           nb +=1
        else
          $update_paths.delete(key)
          msg("#{options[:update_file]}: invalid key '#{key}'",MSG_WARNING)
        end
      rescue ArgumentError
        msg("#{options[:update_file]}: file not found '#{path}'",MSG_ERROR,true)
      end
    end
    msg("#{options[:update_file]}: missing key(s) [needed: {#{UPDATE_PATH_CHECK.keys * ','}}]",MSG_WARNING) \
      if nb != UPDATE_PATH_CHECK.keys.size
  else
    msg("update file '#{options[:update_file]}' not found",MSG_ERROR,true)
  end
end

msg("=== Globals",MSG_INFO)
msg("  mode: #{$mode.to_s}",MSG_INFO)
msg("  sshkeyfile: #{$sshkeyfile}",MSG_INFO)
msg("  updatefile: #{options[:update_file]}",MSG_INFO) if options[:update_file]

# Checking kernels directory
msg("=== Gathering kernels information",MSG_INFO)
msg("invalid directory '#{ARGV[0]}'",MSG_ERROR,true) unless File.directory?(ARGV[0])
deplkernelfiles = Dir.entries(ARGV[0])
deplkernelfiles.delete('.')
deplkernelfiles.delete('..')
vmlinuzfiles = deplkernelfiles.select{ |filename| filename.include?('vmlinuz') }
vmlinuzfiles.each do |vmlinuzfile|
  initrdfile = File.join(ARGV[0],vmlinuzfile.gsub(/vmlinuz/,'initrd'))
  unless File.exist?(initrdfile)
    msg("initrd file for '#{vmlinuzfile}' kernel not found, ignoring kernel",MSG_WARNING)
    next
  end
  name = vmlinuzfile.gsub(/vmlinuz/,'').gsub(/--/,'-')
  $deplkernels[name] = {
    :name => name,
    :vmlinuz => File.join(ARGV[0],vmlinuzfile),
    :initrd => initrdfile
  }
	msg("#{$deplkernels[name][:name]}:",MSG_INFO)
	msg("  vmlinuz: #{$deplkernels[name][:vmlinuz]}",MSG_INFO)
	msg("  initrd: #{$deplkernels[name][:initrd]}",MSG_INFO)
end

msg("no valid deployment kernel found in #{ARGV[0]}",MSG_ERROR,true) if $deplkernels.empty?

# Checking envs directory
msg("=== Gathering environments information",MSG_INFO)
msg("invalid directory '#{ARGV[1]}'",MSG_ERROR,true) unless File.directory?(ARGV[1])
envfiles = Dir.entries(ARGV[1])
envfiles.delete('.')
envfiles.delete('..')

envfiles = envfiles.select { |env| File.file?(File.join(ARGV[1],env)) }

envfiles.each do |env|
	$kaenvs[env] = {}
	$kaenvs[env][:dscfile] = File.join(CFG_KADEPLOY_ENVS_DESC_PATH,File.basename(env))
	tmp = File.new(File.join(ARGV[1],env)).read
	tmp.each do |line|
		if line =~ /^\s*name\s*:\s*([^ ]+)\s*$/
			$kaenvs[env][:name] = Regexp.last_match(1).strip
		elsif line =~ /^\s*tarball\s*:\s*([^ |]+)\|\S+\s*$/
			$kaenvs[env][:tarball] = Regexp.last_match(1).strip
		elsif line =~ /^\s*postinstall\s*:\s*([^ |]+)\|([^ |]+)\|(.*)$/
			$kaenvs[env][:postinstall] = {}
			$kaenvs[env][:postinstall][:file] = Regexp.last_match(1).strip
			$kaenvs[env][:postinstall][:filetype] = Regexp.last_match(2).strip
			$kaenvs[env][:postinstall][:args] = Regexp.last_match(3).strip
		elsif line.strip != '###' and !line.strip.empty?
			$kaenvs[env][:desc] = [] unless $kaenvs[env][:desc]
			$kaenvs[env][:desc] << line
		end
	end
	msg("#{$kaenvs[env][:name]}:",MSG_INFO)
	if $kaenvs[env][:tarball] and File.exist?($kaenvs[env][:tarball])
		msg("  tarball: #{$kaenvs[env][:tarball]}",MSG_INFO)
	else
		msg("can't find env #{env} tarball '#{$kaenvs[env][:tarball]}'",MSG_WARNING)
		$kaenvs.delete(env)
	end
	if $kaenvs[env] and $kaenvs[env][:postinstall]
		if File.exist?($kaenvs[env][:postinstall][:file])
			msg("  postinstall: #{$kaenvs[env][:postinstall][:file]}",MSG_INFO) \
		else
			msg("can't find env #{env} postinstall '#{$kaenvs[env][:postinstall][:file]}'",MSG_WARNING)
			$kaenvs.delete(env)
		end
	end
end

# Kavlan
case $mode
	when :KAVLAN, :VLANKVM
		$kavlan_id = `kavlan --show-vlan-id`
		if $?.success? and !$kavlan_id.empty?
			begin
				Integer($kavlan_id)
			rescue ArgumentError
				msg("kavlan not set",MSG_ERROR,true)
			else
				$kavlan_id = $kavlan_id.to_i
			end
		else
			msg("kavlan not set",MSG_ERROR,true)
		end

		# Disabling DHCP in kavlan
		`kavlan --disable-dhcp`
	when :KVM
	else
		msg('Unknown mode',MSG_ERROR,true)
end


# Checking node list
if $mode == :KAVLAN
  if options[:node_list]
    nodelist_file = options[:node_list]
  elsif (ENV['GOOD_NODES'])
    nodelist_file = ENV['GOOD_NODES']
  elsif (ENV['OAR_NODEFILE'])
    nodelist_file = ENV['OAR_NODEFILE']
  end
else
  nodelist_file = options[:node_list] || nil
end

msg("nodelist parameter not set (see -f option)",MSG_ERROR,true) if !nodelist_file or nodelist_file.empty?

if $mode == :VLANKVM
  if options[:host_list]
    hostlist_file = options[:host_list]
  elsif (ENV['GOOD_NODES'])
    hostlist_file = ENV['GOOD_NODES']
  elsif (ENV['OAR_NODEFILE'])
    hostlist_file = ENV['OAR_NODEFILE']
  else
    msg("hostlist parameter not set (see -F option)",MSG_ERROR,true)
  end

	File.open(hostlist_file, 'r') do |f|
  count = 1
  f.each do |line|
    tmp = line.strip
    begin
      #tmp = getnode(tmp)
      tmpip = Resolv.getaddress(getnode(tmp))
      unless $kanodes[tmp.to_sym]
        $kanodes[tmp.to_sym] = {}
        $kanodes[tmp.to_sym][:name] = "#{HOST_NAME_PREFIX}#{count}"
        $kanodes[tmp.to_sym][:basename] = tmp
        $kanodes[tmp.to_sym][:ipv4] = tmpip
        $kanodes[tmp.to_sym][:type] = :HOST
        count += 1
      end
    rescue Resolv::ResolvError, ArgumentError
      msg("Invalid address for host node '#{tmp}', ignoring",MSG_WARNING)
      $kanodes.delete(tmp.to_sym)
    end
    begin
      addr = IPAddr.new(tmp)
      msg('host nodes should be specified by hostname, ignoring',MSG_WARNING)
      $kanodes.delete(tmp.to_sym)
    rescue ArgumentError
    end
  end
  end
else
  msg("using hostlist parameter with non compatible mode (VLAN-KVM only), ignoring",MSG_WARNING) if options[:host_list]
end

begin
	File.open(nodelist_file, 'r') do |f|
  f.each do |line|
    case $mode
    when :KAVLAN
      $allnodes << line.strip unless $allnodes.include?(line.strip)
    when :KVM, :VLANKVM
      tmp = line.strip.split
      name = tmp[0].strip
      unless $allnodes.include?(name)
        $allnodes << name
        $kanodes[name.to_sym] = {}
        $kanodes[name.to_sym][:basename] = name
        $kanodes[name.to_sym][:name] = name
        $kanodes[name.to_sym][:type] = :NODE if $mode == :VLANKVM
        if tmp[1]
          begin
            Resolv.getaddress(tmp[1])
            $kanodes[name.to_sym][:ipv4] = tmp[1].strip
          rescue Resolv::ResolvError, ArgumentError
            msg("Invalid IP address for node '#{name}', ignoring",MSG_WARNING)
            $allnodes.delete(name)
            $kanodes.delete(name.to_sym)
          end
        else
          msg("No IP address for node '#{name}', ignoring",MSG_WARNING)
          $allnodes.delete(name)
          $kanodes.delete(name.to_sym)
        end

        if tmp[2]
          $kanodes[name.to_sym][:mac] = tmp[2].strip
        else
          msg("No MAC address for node '#{name}', ignoring",MSG_WARNING)
          $allnodes.delete(name)
          $kanodes.delete(name.to_sym)
        end

        if $mode == :VLANKVM
          if tmp[3]
            begin
              tmpip = Resolv.getaddress(tmp[3])

              match = nil
              select_type($kanodes,:HOST).each do |node|
                if node[:ipv4] == tmpip \
                or node[:basename] == tmp[3] \
                or node[:basename].split('.')[0] == tmp[3].split('.')[0]
                  match = node
                  break
                end
              end

              if match
                $kanodes[name.to_sym][:host] = match
              else
                msg("Host machine address '#{tmp[3]}' not found in host list",MSG_ERROR,true)
              end
            rescue Resolv::ResolvError, ArgumentError
              msg("invalid host machine address '#{tmp[3]}', ignoring",MSG_WARNING)
              $allnodes.delete(name)
              $kanodes.delete(name.to_sym)
            end

          else
            msg("No host machine address for node '#{name}', ignoring",MSG_WARNING)
            $allnodes.delete(name)
            $kanodes.delete(name.to_sym)
          end
        end
      end
    else
      msg('Unknown mode',MSG_ERROR,true)
    end
    end
	end
rescue Errno::ENOENT
	msg("File '#{nodelist_file}' not found",MSG_ERROR,true)
end


msg("nodelist parameter empty",MSG_ERROR,true) if $allnodes.empty?
$allnodes.sort!

if $mode == :VLANKVM
  msg("hostlist parameter empty",MSG_ERROR,true) if select_type($kanodes,:HOST).empty?
end

deplnodes = $allnodes.dup

if options[:daemon_kadeploy]
  kaserver = options[:daemon_kadeploy].strip
else
  case $mode
    when :KAVLAN
      kaserver = $allnodes[0]
    when :KVM
      msg('you must specify a Kadeploy daemon (-d option)',MSG_ERROR,true)
    when :VLANKVM
      tmp = select_type($kanodes,:HOST)[0]
      tmp[:type] = :SERVER
      kaserver = tmp[:basename]
    else
      msg('Unknown mode',MSG_ERROR,true)
  end
end


unless $mode == :KVM
	begin
		addr = IPAddr.new(kaserver)
    msg('Kadeploy daemon should be specified by hostname (see -d option)',MSG_ERROR,true)
	rescue ArgumentError
    kaserver = kaserver.split("-#{getgw().split('.')[0]}").join
	end
end

case $mode
  when :KAVLAN
    if deplnodes.include?(kaserver)
      deplnodes.delete(kaserver)
    else
      tmp = deplnodes.select { |node| node =~ /^#{kaserver}/ }
      if tmp.empty?
        msg("Kadeploy daemon not present in <nodes_file>",MSG_WARNING)
      else
        msg("Kadeploy daemon '#{kaserver}' assumed to be '#{tmp[0]}' (which is present in <nodes_file>)",MSG_WARNING)
        kaserver = tmp[0]
        deplnodes.delete(kaserver)
      end
    end
  when :KVM
    begin
      kaserverip = Resolv.getaddress(kaserver)
    rescue Resolv::ResolvError
      msg("invalid Kadeploy daemon hostname '#{kaserver}'",MSG_ERROR,true)
    end
    tmp = $kanodes.select { |n,h| h[:ipv4] == kaserverip }.collect { |v| v[0] }
    unless tmp.nil?
      msg("Kadeploy daemon is present in <nodes_file>",MSG_WARNING)
      tmp.each do |nodetmp|
        deplnodes.delete(nodetmp.to_s)
      end
    end
  when :VLANKVM
    begin
      kaserverip = Resolv.getaddress(getnode(kaserver))
    rescue Resolv::ResolvError
      msg("invalid Kadeploy daemon hostname '#{kaserver}'",MSG_ERROR,true)
    end
    tmp = $kanodes.select { |n,h| h[:basename] =~ /^#{kaserver}/ or h[:ipv4] == kaserverip }.collect { |v| v[0] }
    tmp.each do |nodetmp|
      deplnodes.delete(nodetmp.to_s)
      $kanodes[nodetmp][:type] = :SERVER
    end

  else
    msg('Unknown mode',MSG_ERROR,true)
end

$kanodes[:kadeploy] = {}
$kanodes[:kadeploy][:name] = 'kadeploy'
$kanodes[:kadeploy][:basename] = kaserver
$kanodes[:kadeploy][:ipv4] = kaserverip || nil
$kanodes[:kadeploy][:type] = :SERVER

# >>> TODO: Add options
$kanodes[:dns] = {}
$kanodes[:dns][:name] = 'dns'
$kanodes[:dns][:basename] = $kanodes[:kadeploy][:basename]
$kanodes[:dns][:ipv4] = $kanodes[:kadeploy][:ipv4]
$kanodes[:dns][:type] = :SERVER

$kanodes[:tftp] = {}
$kanodes[:tftp][:name] = 'tftp'
$kanodes[:tftp][:basename] = kaserver
$kanodes[:tftp][:basename] = $kanodes[:kadeploy][:basename]
$kanodes[:tftp][:ipv4] = $kanodes[:kadeploy][:ipv4]
$kanodes[:tftp][:type] = :SERVER

$kanodes[:dhcp] = {}
$kanodes[:dhcp][:name] = 'dhcp'
$kanodes[:dhcp][:basename] = $kanodes[:kadeploy][:basename]
$kanodes[:dhcp][:ipv4] = $kanodes[:kadeploy][:ipv4]
$kanodes[:dhcp][:type] = :SERVER

$kanodes[:sql] = {}
$kanodes[:sql][:name] = 'sql'
$kanodes[:sql][:basename] = $kanodes[:kadeploy][:basename]
$kanodes[:sql][:ipv4] = $kanodes[:kadeploy][:ipv4]
$kanodes[:sql][:type] = :SERVER

$kanodes[:www] = {}
$kanodes[:www][:name] = 'www'
$kanodes[:www][:basename] = $kanodes[:kadeploy][:basename]
$kanodes[:www][:ipv4] = $kanodes[:kadeploy][:ipv4]
$kanodes[:www][:type] = :SERVER

$kanodes[:frontend] = {}
$kanodes[:frontend][:name] = 'frontend'
$kanodes[:frontend][:basename] = $kanodes[:kadeploy][:basename]
$kanodes[:frontend][:ipv4] = $kanodes[:kadeploy][:ipv4]
$kanodes[:frontend][:type] = :SERVER


msg('deploy nodelist empty',MSG_WARNING) if deplnodes.empty?

# Naming deployment nodes
tmp = 1
deplnodes.each do |node|
  name = "#{NODE_NAME_PREFIX}#{tmp}"
  case $mode
  when :KAVLAN
    $kanodes[name.to_sym] = {}
    $kanodes[name.to_sym][:name] = name
    $kanodes[name.to_sym][:basename] = node.strip
    $kanodes[name.to_sym][:type] = :NODE
  when :KVM
    $kanodes[name.to_sym] = $kanodes[node.to_sym].dup
    $kanodes[name.to_sym][:name] = name
    $kanodes[name.to_sym][:type] = :NODE
    $kanodes[name.to_sym][:basename] = node.strip
  end

  tmp += 1
end

$kanodes.values.collect! do |v|
  v[:name] = v[:basename].gsub(/[^\w]/,'') unless v[:name]
  v[:fqdn] = "#{v[:name]}.#{DOMAIN}"
	tmp = nil
	begin
		addr = IPAddr.new(v[:basename])
		# if nodename is an IP address
		if addr.ipv4?
			v[:ipv4] = v[:basename]
		else
			msg("Using IPv6 address for node '#{v[:basename]}', which is currently not supported",MSG_ERROR,true)
		end
		tmp = v[:basename]
	rescue ArgumentError
		# else if nodename is domain name
		tmp = v[:basename].split('.')[0]
	end
  v[:basenodename] = tmp

  if $mode == :KAVLAN and g5k?
    cluster = tmp.split('-')[0]
  else
    cluster = 'default'
  end

  unless $clusters[cluster]
    $clusters[cluster] = {}
    $clusters[cluster][:basename] = cluster
    $clusters[cluster][:name] = "#{cluster}#{CLUSTER_NAME_SUFIX}"
    $clusters[cluster][:nodes] = []
  end
  $clusters[cluster][:nodes] << v
  v[:cluster] = $clusters[cluster]
end

msg("=== Gathering cluster#{$clusters.size > 1 ? 's' : ''} information",MSG_INFO)
$clusters.values.collect! do |v|
  msg("#{v[:basename]}:",MSG_INFO)
  v[:kernel] = $deplkernels[$deplkernels.keys[0]]
  msg("  kernel: #{v[:kernel][:name]}",MSG_INFO)
  v[:drivers] = {}
  if $mode == :KAVLAN and g5k?
    tmp = nil
    begin
      tmp = JSON.parse(RestClient.get(G5K_API + "/grid5000/sites/#{$site.split('.')[0]}/clusters/#{v[:basename]}/nodes/#{v[:nodes][0][:basenodename]}"))
    rescue Exception
      msg("can't gather g5k api information (#{tmp})",MSG_WARNING)
    end
    unless !tmp or tmp.empty?
      v[:drivers][:network] = tmp['network_adapters'].select do |na|
        na['device'] == $netiface
      end[0]['driver']
      v[:drivers][:disk] = tmp['storage_devices'][0]['driver']
    end
    tmpfile = File.join(G5K_POSTINSTALLS_PATH,"preinstall-#{v[:basename]}.tgz")
    if File.exist?(tmpfile)
      v[:postinstall] = tmpfile
    else
      msg("cluster #{v[:basename]} preinstall file not found in '#{G5K_POSTINSTALLS_PATH}'",MSG_WARNING)
    end
  end
  v[:drivers][:network] = DEFAULT_NET_DRIVER unless v[:drivers][:network]
  v[:drivers][:disk] = DEFAULT_DISK_DRIVER unless v[:drivers][:disk]

  msg("  net driver: #{v[:drivers][:network]}",MSG_INFO)
  msg("  disk driver: #{v[:drivers][:disk]}",MSG_INFO)
end


Net::SSH.start(getgw(), ENV['USER'], :keys => $sshkeyfile) do |gwsession|
sshgw = Net::SSH::Gateway.new(getgw(), ENV['USER'], :keys => $sshkeyfile)

begin
  pubkey = File.open("#{$sshkeyfile}.pub",'r').read
rescue Errno::ENOENT
  msg("user public key file '#{$sshkeyfile}.pub' not found",MSG_WARNING)
else
  tmp = sexec(gwsession,"grep '#{pubkey}' ~#{ENV['USER']}/.ssh/authorized_keys; true;")[0]
  sexec(gwsession,"echo '#{pubkey}' >> ~#{ENV['USER']}/.ssh/authorized_keys") if !tmp or tmp.empty?
end

server=$kanodes[:dns]
servername=getnode(server[:basename])
msg('=== Gathering network information',MSG_INFO)
sshgw.ssh(servername,'root') do |session|
  msg("Connected to #{server[:basename]}",MSG_INFO)

  msg('Getting network information',MSG_INFO)
	set_default_route(session) if $mode == :KVM
  tmp = sexec(session,'route -n')
  msg('can\'t get route informations',MSG_ERRO,true) if !tmp or tmp.empty?
  defaultiface = nil
  tmp.each do |line|
    if line =~ /^(\S+)\s+0\.0\.0\.0\s+(\S+)\s+.+$/
      $network[:ipv4] = Regexp.last_match(1)
      $network[:mask] = Regexp.last_match(2)
      $network[:ipaddr] = IPAddr.new("#{$network[:ipv4]}/#{$network[:mask]}")
      $network[:broadcast] = ($network[:ipaddr] | (~$network[:ipaddr].instance_variable_get(:@mask_addr) & IPAddr::IN4MASK)).to_s
    elsif line =~ /^0\.0\.0\.0\s+(\S+)\s+.+\s+(\S+)\s*$/
      $network[:gateway] = Regexp.last_match(1)
      defaultiface = Regexp.last_match(2)
    end
  end

  if $network.empty?
    msg('unable to gather network information',MSG_ERROR,true)
  else
    msg('Network config:',MSG_INFO)
    msg("  addresses: #{$network[:ipv4]}/#{$network[:mask]}",MSG_INFO)
    msg("  gateway: #{$network[:gateway]}",MSG_INFO)
    msg("  broadcast: #{$network[:broadcast]}",MSG_INFO)
  end
  msg('can\'t find default network iface',MSG_ERROR,true) if !defaultiface or defaultiface.empty?

  msg('Gathering DNS server IPv4/MAC addresses',MSG_INFO)
  tmp = sexec(session,"ifconfig #{defaultiface}")
  msg('can\'t ifconfig default network iface',MSG_ERROR,true) if !tmp or tmp.empty?
  mac = nil
  ipv4 = nil
  tmp.each do |line|
    if line.include?('HWaddr')
      mac = line.split('HWaddr')[1].strip.split[0]
    elsif line.include?('inet addr:')
      ipv4 = line.split('inet addr:')[1].strip.split[0]
    end
  end
  msg("can\'t collect IPv4/MAC on #{$kanodes[:dns][:basename]}",MSG_ERROR,true) \
    if !mac or !ipv4 or mac.empty? or ipv4.empty?

  msg('Updating nodes IPv4/MAC addresses',MSG_INFO)
  $kanodes.values.each do |node|
    if node == :dns or node[:basename].split('.')[0] == $kanodes[:dns][:basename].split('.')[0]
      node[:mac] = mac
      node[:ipv4] = ipv4
    end
  end

	if $mode == :KAVLAN or $mode == :VLANKVM
    http_tunnel(server,session) do
      msg('Updating debian packages list',MSG_INFO)
      apt_update(session)

      msg('Getting nodes IPv4/MAC addresses',MSG_INFO)
      apt_install(session,'syslinux')

      nodes=[]
	    if $mode == :KAVLAN
        nodes = $kanodes.values
      else
        nodes = select_type($kanodes,:HOST)
      end

      nodes.each do |node|
        if !node[:ipv4]
          tmp = sexec(session,"gethostip -d #{getnode(node[:basename])}")[0]
          msg("can't get '#{node[:basename]}' IPv4 address",MSG_ERROR,true) if !tmp or tmp.empty?
          node[:ipv4] = tmp
        end

        if !node[:mac]
          tmp = sexec(session,"ping -c 1 #{node[:ipv4]} &>/dev/null; arp -n | grep '^#{node[:ipv4]} '")[0]
          msg("can't resolv '#{node[:basename]}' MAC address",MSG_ERROR,true) if !tmp or tmp.empty?
          node[:mac] = tmp.split[2].chomp
        end

        msg("can\'t collect IPv4/MAC on #{node[:basename]}",MSG_ERROR,true) \
          if !node[:mac] or !node[:ipv4] or node[:mac].empty? or node[:ipv4].empty?
      end

      msg('Removing configuration related packages',MSG_INFO)
      apt_remove(session,'syslinux')
    end
  end
end
msg("Disconnected from #{server[:basename]}",MSG_INFO)
msg("",MSG_INFO)

server=$kanodes[:dns]
servername=getnode(server[:basename])
msg('=== Setting up DNS server',MSG_INFO)
sshgw.ssh(servername,'root') do |session|
  msg("Connected to #{server[:basename]}",MSG_INFO)

	http_tunnel(server,session) do
		msg('Updating debian packages list',MSG_INFO)
		apt_update(session)

		msg('Installing DNS server',MSG_INFO)
		apt_install(session,'bind9')


		msg('Configuring DNS server',MSG_INFO)


		tempfile(cfg_dns_master()) {|path| scp(servername,path,cfg_bind_master_file())}
		sexec(session,"chown bind #{cfg_bind_master_file()}")

		tempfile(cfg_dns_reverse()) {|path| scp(servername,path,cfg_bind_reverse_file())}
		sexec(session,"chown bind #{cfg_bind_reverse_file()}")

=begin
		tmp = sexec(session,"grep '^nameserver' #{CFG_RESOLVCONF_FILE}")[0]
		if !tmp or tmp.empty?
			tmp = ''
			msg('no nameserver in resolv.conf file',MSG_WARNING)
		else
			tmp = tmp.split[1]
		end
=end
		# Assume that default DNS server is the network gateway
		tmp = $network[:gateway]
		tempfile(cfg_bind((tmp != $kanodes[:dns][:ipv4] ? tmp : ''))) do |path|
			scp(servername,path,CFG_BIND_NAMED_FILE)
		end
		sexec(session,"chown bind #{CFG_BIND_NAMED_FILE}")

		sexec(session,'service bind9 restart')

		msg('Updating resolv.conf files',MSG_INFO)
		tempfile(cfg_resolvconf()) {|path| scp(servername,path,CFG_RESOLVCONF_FILE)}

		excls = []
		excls << $kanodes[:dns][:ipv4]

    nodes=[]
    if $mode == :VLANKVM
      nodes = select_type($kanodes,:SERVER) + select_type($kanodes,:HOST)
    else
      nodes = select_type($kanodes,:SERVER)
    end
		nodes.each do |node|
			unless excls.include?(node[:ipv4])
				sexec(session,"scp -r #{SSH_OPTIONS} #{CFG_RESOLVCONF_FILE} root@#{node[:ipv4]}:#{CFG_RESOLVCONF_FILE}")
				excls << node[:ipv4]
			end
		end
	end
end
msg("Disconnected from #{server[:basename]}",MSG_INFO)
msg("",MSG_INFO)


server=$kanodes[:tftp]
servername=getnode(server[:basename])
msg('=== Setting up TFTP server',MSG_INFO)
sshgw.ssh(servername,'root') do |session|
  msg("Connected to #{server[:basename]}",MSG_INFO)

	http_tunnel(server,session) do
		msg('Updating debian packages list',MSG_INFO)
		apt_update(session)

		msg('Installing TFTP server',MSG_INFO)
		apt_install(session,'debconf-utils')
		sexec(session,"rm -Rf #{CFG_TFTP_PATH}")
		sexec(session,"mkdir -p #{CFG_TFTP_PATH}")
		sexec(session,"echo 'tftpd-hpa tftpd-hpa/directory string #{CFG_TFTP_PATH}' | debconf-set-selections")
		sexec(session,"echo 'tftpd-hpa tftpd-hpa/username string #{CFG_TFTP_USER}' | debconf-set-selections")
		apt_install(session,'tftpd-hpa')

		msg('Configuring TFTP server',MSG_INFO)
		tempfile(cfg_tftp()) {|path| scp(servername,path,CFG_TFTP_CONF_FILE)}
		sexec(session,'service tftpd-hpa restart')

		msg('Installing bootfiles',MSG_INFO)
		apt_install(session,'syslinux-common')
		CFG_PXE_BOOTFILES.each do |bootfile|
			tmp = sexec(session,"dpkg -L syslinux-common | grep '^.*/#{bootfile}$'",false,false)
			msg("mandatory bootfile '#{bootfile}' not found in syslinux-common package",
				MSG_ERROR,true) if !tmp or tmp.empty? or !tmp[0] or tmp[0].empty?
			sexec(session,"ln -f #{tmp[0]} #{CFG_TFTP_PATH}")
		end

    sexec(session,"mkdir -p #{CFG_PXE_KERNELS_PATH}")

    if $deploysendmeth == :TFTP
      msg('Sending deployment kernels',MSG_INFO)
      $deplkernels.each do |name,kernel|
        msg("\t#{name}",MSG_INFO)
        scp(servername,kernel[:vmlinuz],CFG_PXE_KERNELS_PATH)
        scp(servername,kernel[:initrd],CFG_PXE_KERNELS_PATH)
      end
    end

		msg('Creating pxelinux configs',MSG_INFO)
		sexec(session,"mkdir -p #{CFG_PXE_CONFIG_PATH}")
		#apt_install(session,'syslinux')
		tempfile(cfg_pxe()) do |path|
			scp(servername,path,File.join(CFG_PXE_CONFIG_PATH,'default'))
=begin
      tmpcmd = ''
			select_type($kanodes,:NODE).each do |node|
				#tmp = sexec(session,"gethostip -x #{node[:fqdn]}")[0]
				#msg("gethostip failed for '#{node[:fqdn]}', aborting",MSG_ERROR,true) \
				#  if !tmp or tmp.empty?

				tmp = IPAddr.new(node[:ipv4]).instance_variable_get(:@addr).to_s(16).upcase
        tmpcmp += "cp #{File.join(CFG_PXE_CONFIG_PATH,'default')} #{File.join(CFG_PXE_CONFIG_PATH,tmp)}; "
			end
      sexec(session,tmpcmd)
=end
		end

		sexec(session,"chown #{CFG_TFTP_USER}:#{CFG_TFTP_USER} -R #{CFG_TFTP_PATH}")
		sexec(session,"chmod -R 755 #{CFG_TFTP_PATH}")

		msg('Removing configuration related packages',MSG_INFO)
		apt_remove(session,['debconf-utils'])
	end
end
msg("Disconnected from #{server[:basename]}\n",MSG_INFO)
msg("",MSG_INFO)

if $deploysendmeth == :HTTP

  server=$kanodes[:www]
  servername=getnode(server[:basename])
  msg('=== Setting up HTTP server',MSG_INFO)
  sshgw.ssh(servername,'root') do |session|
    msg("Connected to #{server[:basename]}",MSG_INFO)

    http_tunnel(server,session) do
      msg('Updating debian packages list',MSG_INFO)
      apt_update(session)

      msg('Installing HTTP server',MSG_INFO)
      apt_install(session,'apache2')
      sexec(session,"rm -Rf #{CFG_APACHE_SERVER_PATH}")
      sexec(session,"mkdir -p #{CFG_APACHE_SERVER_PATH}")
      sexec(session,"chmod 755 #{CFG_APACHE_SERVER_PATH}")

      msg('Configuring HTTP server',MSG_INFO)
      #tempfile(cfg_apache()) {|path| scp(servername,path,CFG_APACHE_CONF_FILE)}
      sexec(session,'service apache2 restart')

      msg('Sending deployment kernels',MSG_INFO)
      sexec(session,"mkdir -p #{CFG_APACHE_KERNELS_PATH}")
      sexec(session,"chmod 755 #{CFG_APACHE_KERNELS_PATH}")
      $deplkernels.each do |name,kernel|
        msg("\t#{name}",MSG_INFO)
        scp(servername,kernel[:vmlinuz],CFG_APACHE_KERNELS_PATH)
        scp(servername,kernel[:initrd],CFG_APACHE_KERNELS_PATH)
      end

      sexec(session,"chmod -R 755 #{CFG_APACHE_KERNELS_PATH}")

    end
  end
  msg("Disconnected from #{server[:basename]}\n",MSG_INFO)
  msg("",MSG_INFO)

end

server=$kanodes[:dhcp]
servername=getnode(server[:basename])
msg('=== Setting up DHCP server',MSG_INFO)
sshgw.ssh(servername,'root') do |session|
  msg("Connected to #{server[:basename]}",MSG_INFO)

	http_tunnel(server,session) do
		msg('Updating debian packages list',MSG_INFO)
		apt_update(session)

		msg('Installing DHCP server',MSG_INFO)
		apt_install(session,'isc-dhcp-server')

		msg('Configuring DHCP server',MSG_INFO)
		tempfile(cfg_dhcp()) {|path| scp(servername,path,CFG_DHCP_CONF_FILE)}
		sexec(session,'service isc-dhcp-server restart')

		msg('Reloading network interfaces',MSG_INFO)
		sexec(session,'service networking restart &>/dev/null')
=begin
		excls = []
		excls << $kanodes[:dhcp][:ipv4]
		Net::SSH::Multi.start do |bcastsession|
			bcastsession.via getgw(), ENV['USER']

      nodes=[]
      if $mode == :VLANKVM
        nodes = select_type($kanodes,:SERVER) + select_type($kanodes,:HOST)
      else
        nodes = select_type($kanodes,:SERVER)
      end

      nodes.each do |node|
				unless excls.include?(node[:ipv4])
					bcastsession.use "root@#{node[:ipv4]}"
					excls << node[:ipv4]
				end
			end

			bcastsession.exec('service networking restart &>/dev/null')
		end
=end
	end
end
msg("Disconnected from #{server[:basename]}\n",MSG_INFO)
msg("",MSG_INFO)


server=$kanodes[:sql]
servername=getnode(server[:basename])
msg('=== Setting up SQL server',MSG_INFO)
sshgw.ssh(servername,'root') do |session|
  msg("Connected to #{server[:basename]}",MSG_INFO)

	http_tunnel(server,session) do
		msg('Updating debian packages list',MSG_INFO)
		apt_update(session)

		msg('Installing mySQL server',MSG_INFO)
		apt_install(session,'debconf-utils')
		sexec(session,"echo 'mysql-server-#{CFG_MYSQL_VERSION} mysql-server/root_password password #{CFG_SQL_PASS_ROOT}' | debconf-set-selections")
		sexec(session,"echo 'mysql-server-#{CFG_MYSQL_VERSION} mysql-server/root_password_again password #{CFG_SQL_PASS_ROOT}' | debconf-set-selections")
		apt_install(session,'mysql-server')

		msg('Configuring mySQL server',MSG_INFO)
		#sexec("cat #{CFG_MYSQL_CONF_FILE} | sed -e '/bind-address/d' > #{tmp}; mv -f #{tmp} #{CFG_MYSQL_CONF_FILE}")
		tempfile(cfg_mysql()) {|path| scp(servername,path,CFG_MYSQL_CONF_FILE)}
		sexec(session,'service mysql restart')

		msg('Creating Kadeploy database',MSG_INFO)
		tmp = sexec(session,'tempfile')[0]
		msg('can\'t get temporary file',MSG_ERROR,true) if !tmp or tmp.empty?
		tempfile(cfg_sql()) {|path| scp(servername,path,tmp)}
		sexec(session,"mysql --user=root --password=#{CFG_SQL_PASS_ROOT} < #{tmp}")
		sexec(session,"rm #{tmp}")

		msg('Removing configuration related packages',MSG_INFO)
		apt_remove(session,'debconf-utils')
	end
end
msg("Disconnected from #{server[:basename]}\n",MSG_INFO)
msg("",MSG_INFO)

server=$kanodes[:kadeploy]
servername=getnode(server[:basename])
msg('=== Setting up Kadeploy server',MSG_INFO)
sshgw.ssh(servername,'root') do |session|
  msg("Connected to #{server[:basename]}",MSG_INFO)

	kadeploy_tunnel(server,session) do
		msg('Updating debian packages list',MSG_INFO)
		apt_update(session)

		msg('Creating Kadeploy directories',MSG_INFO)
		sexec(session,"touch #{CFG_KADEPLOY_LOGFILE}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_LOGFILE}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_CACHE_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_CACHE_PATH}")
    sexec(session,"rm -Rf #{CFG_KADEPLOY_VAR_PATH}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_VAR_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_VAR_PATH}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_HOSTNAMES_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_HOSTNAMES_PATH}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_ENVS_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_PATH}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_ENVS_IMAGES_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_IMAGES_PATH}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_ENVS_DESC_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_DESC_PATH}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_PREINSTALLS_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_PREINSTALLS_PATH}")
    if $mode == :KVM or $mode == :VLANKVM
      sexec(session,"mkdir -p #{CFG_KADEPLOY_KVM_PROCS_PATH}")
      sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_KVM_PROCS_PATH}")
      if $mode == :VLANKVM
        sexec(session,"mkdir -p #{CFG_KADEPLOY_KVM_HOSTS_PATH}")
        sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_KVM_HOSTS_PATH}")
      end
    end

		msg('Copying clusters postinstall files',MSG_INFO)
		$clusters.values.each do |cluster|
			postinstallpath = cfg_kadeploy_specific_conf_postinstall_path(cluster)
			if postinstallpath
				scp(servername,cluster[:postinstall],postinstallpath)
				sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{postinstallpath}")
			end
		end

		msg('Copying and configuring environments',MSG_INFO)
		$kaenvs.values.each do |env|
			msg("  #{env[:name]} config",MSG_INFO)
			scp(servername,env[:tarball],File.join(CFG_KADEPLOY_ENVS_IMAGES_PATH,File.basename(env[:tarball])))
			scp(servername,env[:postinstall][:file],File.join(CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH,File.basename(env[:postinstall][:file]))) if env[:postinstall]
			tempfile(cfg_environment_desc(env)) do |path|
				scp(servername,path,env[:dscfile])
			end
		end
		sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_IMAGES_PATH}")
		sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_DESC_PATH}")
		sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH}")

    if options[:kastafior]
      msg('Installing Kastafior',MSG_INFO)
			scp(servername,options[:kastafior],CFG_KASTAFIOR_BIN_FILE)
    end

		msg('Installing Kadeploy server/client',MSG_INFO)
		apt_install(session,['kadeploy-server','kadeploy-client'])

		sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_SSHKEY_PATH}")

		if options[:update_file]
			msg('Installing remote kadeploy files',MSG_INFO)
			msg('Installing sshfs',MSG_INFO)
			apt_install(session,'fuse-utils')

			msg("Creating local permanent tunnel to #{}:22 on localhost:#{UPDATE_FORWARD_PORT}",MSG_INFO)
			ssh_tunnel_create(session,22,$srchost,UPDATE_FORWARD_PORT)

			tmp = sexec(session,'mktemp -d')
			msg('can\'t create temp directory',MSG_ERROR,true) if !tmp or tmp.empty?
			msg("Mounting #{$update_paths[UPDATE_DIR_VAR]} in #{tmp} with sshfs",MSG_INFO)
			sexec(session,"sshfs #{SSH_OPTIONS} -o allow_other -p #{UPDATE_FORWARD_PORT} #{ENV['USER']}@localhost:#{$update_paths[UPDATE_DIR_VAR]} #{tmp}")

			kadeploy_update(session,tmp)
		end

		msg('Setting up hostnames hack',MSG_INFO)
		scp(servername,$sshkeyfile,CFG_KADEPLOY_HOSTNAMES_SSHKEY)
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_HOSTNAMES_SSHKEY}")

    tmpcmds = []
		select_type($kanodes,:NODE).each do |node|
			tmpcmds << "echo '#{node[:fqdn]}' > #{File.join(CFG_KADEPLOY_HOSTNAMES_PATH,node[:basename])}"
			tmpcmds << "echo '#{node[:basename]}' > #{File.join(CFG_KADEPLOY_HOSTNAMES_PATH,node[:fqdn])}"
      tmpcmds << "echo '#{node[:host][:ipv4]}' > #{File.join(CFG_KADEPLOY_KVM_HOSTS_PATH,node[:fqdn])}" if $mode == :VLANKVM
		end
    sexec(session,tmpcmds.join(';'))
		sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_HOSTNAMES_PATH}")
    sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_KVM_HOSTS_PATH}") if $mode == :VLANKVM

		msg('Configuring Kadeploy server',MSG_INFO)
    sexec(session,"mkdir -p /root/.ssh; grep \"$(cat #{CFG_KADEPLOY_SSHKEY_DEFAULT}.pub)\" /root/.ssh/authorized_keys || cat #{CFG_KADEPLOY_SSHKEY_DEFAULT}.pub >> /root/.ssh/authorized_keys")
		tempfile(cfg_kadeploy_conf()) {|path| scp(servername,path,CFG_KADEPLOY_CONF_CONF_FILE)}
		tempfile(cfg_kadeploy_cmd()) {|path| scp(servername,path,CFG_KADEPLOY_CMD_CONF_FILE)}
		tempfile(cfg_kadeploy_clusters()) {|path| scp(servername,path,CFG_KADEPLOY_CLUSTERS_CONF_FILE)}
		tempfile(cfg_kadeploy_nodes()) {|path| scp(servername,path,CFG_KADEPLOY_NODES_CONF_FILE)}
		$clusters.values.each do |cluster|
			filepath = CFG_KADEPLOY_PARTITION_CONF_FILE_PREFIX+cluster[:name]
			tempfile(cfg_kadeploy_partition_file(cluster)) do |path|
				scp(servername,path,filepath)
			end
			sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{filepath}")

			filepath = CFG_KADEPLOY_SPECIFIC_CONF_FILE_PREFIX+cluster[:name]
			tempfile(cfg_kadeploy_specific_conf(cluster)) do |path|
				scp(servername,path,filepath)
			end
			sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{filepath}")
		end
		sexec(session,'service kadeploy3d restart')

		msg('Configuring Kadeploy client',MSG_INFO)
		tempfile(cfg_kadeploy_client()) do |path|
			scp(servername,path,CFG_KADEPLOY_CLIENT_CONF_FILE)
		end
		sexec(session,"chmod +r #{CFG_KADEPLOY_CLIENT_CONF_FILE}")

		# Ugly hack to be removed when the repository will be updated
		msg('Installing ruby',MSG_INFO)
		apt_install(session,'ruby')


		msg('Adding environments',MSG_INFO)
		$kaenvs.values.each do |env|
			sexec(session,"kaenv3 -u #{CFG_KADEPLOY_USER} -a #{env[:dscfile]}")
			msg("  #{env[:name]} ok",MSG_INFO)
		end

		msg('Set rights for frontend user',MSG_INFO)
    tmpcmds = []
		select_type($kanodes,:NODE).each do |node|
			tmpcmds << "-m #{node[:fqdn]}"
		end
    sexec(session,"karights3 --overwrite-rights -a #{tmpcmds.join(' ')} -p #{cfg_kadeploy_disk_device()}#{CFG_KADEPLOY_PARTITION_DEPLOY_ID} -u #{CFG_FRONTEND_USER}")

		msg('Removing configuration related packages',MSG_INFO)
		#apt_remove(session,'kadeploy-client')
	end
end
msg("Disconnected from #{server[:basename]}\n",MSG_INFO)
msg("",MSG_INFO)

=begin

if $mode == :VLANKVM
  msg('=== Setting up host nodes for KVM',MSG_INFO)
  msg("Installing KVM packages",MSG_INFO)
  select_type($kanodes,:HOST).each do |node|
    sshgw.ssh(getnode(node[:basename]),'root') do |session|
      http_tunnel(node,session,false) do
        apt_install(session,KVM_PACKAGES * ' ')
      end
    end
    msg("\t#{node[:name]} (#{node[:basename]}) ok",MSG_INFO)
  end

  msg("Configuring network bridges",MSG_INFO)
  select_type($kanodes,:HOST).each do |node|
    sshgw.ssh(getnode(node[:basename]),'root') do |session|
      tmp = sexec(session,"ifconfig -a -s | grep '^#{KVM_BRIDGE_DEV}.*$'; true")
      # Creating the bridge
      if !tmp or tmp.empty?
        # Getting default interface name
        tmp = sexec(session,'route -n')
        msg('can\'t get route informations',MSG_ERRO,true) if !tmp or tmp.empty?
        defaultiface = nil
        tmp.each do |line|
          if line =~ /^0\.0\.0\.0\s+\S+\s+.+\s+(\S+)\s*$/
            defaultiface = Regexp.last_match(1)
          end
        end

        if !defaultiface or defaultiface.empty?
          msg("can't get default iface, using #{NET_ADMIN_IFACE}",MSG_WARNING)
          defaultiface = NET_ADMIN_IFACE
        end

        tempfile(cfg_networking_bridge(defaultiface,node[:mac])) do |path|
          scp(getnode(node[:basename]),path,CFG_NETWORKING_CONF_FILE)
        end

        sexec(session,'service networking restart &>/dev/null')
      end
    end
    msg("\t#{node[:name]} (#{node[:basename]}) ok",MSG_INFO)
  end
  msg("",MSG_INFO)
end

=end

server=$kanodes[:frontend]
servername=getnode(server[:basename])
msg('=== Setting up frontend',MSG_INFO)
sshgw.ssh(servername,'root') do |session|
  msg("Connected to #{server[:basename]}",MSG_INFO)

	kadeploy_tunnel(server,session) do
		msg('Updating debian packages list',MSG_INFO)
		apt_update(session)

		msg('Installing Kadeploy client',MSG_INFO)
		apt_install(session,'kadeploy-client')

		msg('Configuring Kadeploy client',MSG_INFO)
		tempfile(cfg_kadeploy_client()) do |path|
			scp(servername,path,CFG_KADEPLOY_CLIENT_CONF_FILE)
		end
		sexec(session,"chmod +r #{CFG_KADEPLOY_CLIENT_CONF_FILE}")
	end

	http_tunnel(server,session) do
		msg('Installing additional packages',MSG_INFO)
		apt_install(session,CFG_FRONTEND_PACKAGES)

		msg("Creating frontend user '#{CFG_FRONTEND_USER}'",MSG_INFO)
		sexec(session,"userdel --force --remove #{CFG_FRONTEND_USER}; true ;")
		sexec(session,"useradd --create-home --user-group --shell \"`which #{CFG_FRONTEND_SHELL}`\" --password '#{CFG_FRONTEND_USER_PASS}' #{CFG_FRONTEND_USER}")

		msg("Generating frontend user ssh key pair",MSG_INFO)
		sexec(session,"mkdir -p #{File.join("~#{CFG_FRONTEND_USER}",'.ssh')}")
		sexec(session,"chown #{CFG_FRONTEND_USER}:#{CFG_FRONTEND_USER} #{File.join("~#{CFG_FRONTEND_USER}",'.ssh')}")
		sexec(session,"ssh-keygen -f #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','identity')} -N '' -C '#{CFG_FRONTEND_USER}@#{server[:fqdn]}'")
		sexec(session,"chown #{CFG_FRONTEND_USER}:#{CFG_FRONTEND_USER} #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','identity')}")
		sexec(session,"chown #{CFG_FRONTEND_USER}:#{CFG_FRONTEND_USER} #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','identity.pub')}")

		msg("Copying user public key",MSG_INFO)
		begin
			pubkey = File.open("#{$sshkeyfile}.pub",'r').read
		rescue Errno::ENOENT
			msg("user public key file '#{$sshkeyfile}.pub' not found",MSG_WARNING)
		else
			sexec(session,"touch #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','authorized_keys')}")
			sexec(session,"chown #{CFG_FRONTEND_USER}:#{CFG_FRONTEND_USER} #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','authorized_keys')}")
			tmp = sexec(session,"grep '#{pubkey}' #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','authorized_keys')}; true;")[0]
			sexec(session,"echo '#{pubkey}' >> #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','authorized_keys')}") if !tmp or tmp.empty?
		end
		sexec(session,"cat #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','identity.pub')} >> #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','authorized_keys')}")

		if options[:debpackages] and !options[:debpackages].empty?
			msg("Installing additional packages '#{options[:debpackages].join(',')}'",MSG_INFO)
			apt_install(session,options[:debpackages])
		end
	end
end
msg("Disconnected from #{server[:basename]}\n",MSG_INFO)
msg("",MSG_INFO)

end

msg("Installation done",MSG_INFO)
msg("Deploiement nodes:")
select_type($kanodes,:NODE).each do |node|
  msg("  #{node[:fqdn]} (#{node[:basename]})")
end
msg("Frontend: #{CFG_FRONTEND_USER}@#{getnode($kanodes[:frontend][:basename])}")

