#!/usr/bin/ruby

require 'tempfile'

USAGE = "Usage: #{$0} <gateway_user> <gateway_address> [<ssh_key_path>]"

PROXY_ADDR = 'proxy'
PROXY_PORT = '3128'
SSH_KEY = '/tmp/identity'
SSH_OPTIONS	= '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o PreferredAuthentications=publickey'
APT_OPTIONS = " -o Acquire::http::Proxy=\"http://localhost:#{PROXY_PORT}\" "
APT_REPO_URL = "http://ftp.fr.debian.org/debian"
APT_REPO_VARIANT = "testing"
APT_REPO_CONF_FILE = '/etc/apt/sources.list'

KVM_PACKAGES = [ 'kvm', 'qemu', 'qemu-kvm' , 'bridge-utils', 'screen' ]
BRIDGE_DEV = 'br0'
ADMIN_IFACE = 'eth0'
NETWORKING_CONF_FILE = '/etc/network/interfaces'

EXCL_DEVS = [ BRIDGE_DEV,'lo' ]


def cmd(cmd,critical=true)
  ret = `#{cmd}`.split("\n")
  if critical and !$?.success?
    puts "error when executing '#{cmd}': #{ret}"
    exit 1
  end
  ret
end

SSH_TUNNEL_TIMEOUT=20
def ssh_tunnel(gwuser,gwhost,dstport,dsthost,srcport=nil,srchost=nil)
  srcport = dstport unless srcport

  tmp = cmd("lsof -i4 | grep LISTEN | grep localhost:#{srcport}; true")[0]
  if tmp and !tmp.empty?
    cmd("kill #{tmp.chomp.split[1]}")
    time_start = Time.now
    begin
      tmp = cmd("lsof -i4 | grep LISTEN | grep localhost:#{srcport}; true")[0]
      cmd("kill -9 #{tmp.chomp.split[1]}") if (Time.now - time_start) > 2
      sleep(0.1)
    end until !tmp or tmp.empty?
  end
  cmd("ssh #{SSH_OPTIONS} -N -L #{srcport}:#{dsthost}:#{dstport} -i #{$sshkeyfile} #{gwuser}@#{gwhost} &>/dev/null &")
  time_start = Time.now
  begin
    tmp = cmd("lsof -i4 | grep LISTEN | grep localhost:#{srcport}; true")[0]
    sleep(0.1)
    if Time.now - time_start > SSH_TUNNEL_TIMEOUT
      puts "SSH tunnel creation on #{srchost}:#{srcport} failed"
      exit 1
    end
  end while !tmp or tmp.empty?
  tunpid = tmp.split[1]

  yield

  cmd("kill #{tunpid}")
end

def cfg_networking_bridge(ifname,macaddr)
  "auto lo\n"\
  "iface lo inet loopback\n\n"\
  "iface #{ifname} inet manual\n\n"\
  "auto #{BRIDGE_DEV}\n"\
  "iface #{BRIDGE_DEV} inet dhcp\n"\
  "  bridge_ports #{ifname}\n"\
  "  bridge_stp      off\n"\
  "  bridge_maxwait  0\n"\
  "  bridge_fd       0\n"\
  "bridge_hw #{macaddr}\n\n"
end

if ARGV.size < 2
  puts USAGE
  exit 1
end

if !ARGV[2] or ARGV[2].empty?
  $sshkeyfile = SSH_KEY
else
  $sshkeyfile = SSH_KEY
end

unless File.exists?($sshkeyfile)
  puts "file not found '#{$sshkeyfile}'"
  exit 1
end

tmp = cmd("grep '^deb' #{APT_REPO_CONF_FILE} | grep #{APT_REPO_URL} | grep #{APT_REPO_VARIANT}; true")

cmd("echo 'deb #{APT_REPO_URL} #{APT_REPO_VARIANT} main contrib non-free' >> #{APT_REPO_CONF_FILE}") if !tmp or tmp.empty?

ssh_tunnel(ARGV[0],ARGV[1],PROXY_PORT,PROXY_ADDR,PROXY_PORT) do
  cmd("apt-get #{APT_OPTIONS} update -q")
  cmd("apt-get #{APT_OPTIONS} install -t #{APT_REPO_VARIANT} -q --yes --force-yes #{KVM_PACKAGES.join(' ')}")
end

tmp = cmd("ifconfig -a -s")

ifaces=[]
tmp.each do |line|
  unless line =~ /^\s*Iface.*$/
    ifaces << line.split()[0]
  end
end

# Creating the bridge
if !ifaces.include?(BRIDGE_DEV) or ifaces.empty?
  ifaces -= EXCL_DEVS

  # Getting default interface name
  tmp = cmd("route -n")
  if !tmp or tmp.empty?
    puts 'can\'t get route informations'
    exit 1
  end

  defaultiface = nil
  tmp.each do |line|
    if line =~ /^0\.0\.0\.0\s+\S+\s+.+\s+(\S+)\s*$/
      defaultiface = Regexp.last_match(1)
    end
  end

  if !defaultiface or defaultiface.empty?
    puts "can't get default iface, using #{ADMIN_IFACE}"
    defaultiface = ADMIN_IFACE
  end

  tmp = cmd("ifconfig #{defaultiface}")
  if !tmp or tmp.empty?
    puts 'can\'t ifconfig default network iface'
    exit 1
  end

  mac = nil
  #ipv4 = nil
  tmp.each do |line|
    if line.include?('HWaddr')
      mac = line.split('HWaddr')[1].strip.split[0]
    #elsif line.include?('inet addr:')
    #  ipv4 = line.split('inet addr:')[1].strip.split[0]
    end
  end

  ifaces.delete(defaultiface)

  ifaces.each do |iface|
    cmd("ifconfig #{iface} down")
  end

  tmp = Tempfile.new('networking')
  tmp.write(cfg_networking_bridge(defaultiface,mac))
  tmp.close
  cmd("cp -f #{tmp.path} #{NETWORKING_CONF_FILE}")
  tmp.unlink

  cmd("service networking restart &>/dev/null")
end

